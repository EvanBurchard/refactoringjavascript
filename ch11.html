<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Refactoring JavaScript</title>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script>
    <link rel="stylesheet" type="text/css" href="theme/html/html.css">
  </head>
  <body data-type="book">
    <section data-type="chapter" id="functional-refactoring-MXEuV">
<h1>Functional Refactoring</h1>

<p>Of all the styles of JavaScript you can write, this one probably draws from the deepest well. Functional programming is older than Object-Oriented Programming and even Imperative Programming. We're going to take a few drinks from this well, but try to avoid falling in. FP has so much history and theory behind it that we have to set some boundaries.</p>

<p>There is an expression that "farmers don't want to own all the land, just all the land their land touches."</p>

<p>Learning functional programming in JavaScript has this same temptation. Here is a list of statements that might hold true for some people, but are not what we we're dealing with in this chapter:</p>

<ul>
	<li>To learn functional programming, you need to learn Scheme/Haskell.</li>
	<li>To do "real" functional programming in JavaScript, you need to compile to JS from PureScript, TypeScript, ClojureScript, or something else.</li>
	<li>To learn functional programming, you need to learn the lambda calculus.</li>
	<li>To learn functional programming, you need to learn category theory.</li>
</ul>

<aside data-type="sidebar" id="a-confession-2XsKSO">
<h5>A Confession</h5>

<p>An implicit statement in the above is:</p>

<p>"Evan needs to write this chapter as a 900 page book from the perspective of Math/CS dual PhD (which he isn't)."</p>

<p>Sorry to disappoint, but that's not going to happen in this chapter.</p>
</aside>

<p>The focus here is entirely on the practical concern we've had all along: confidence through developing and maintaining the interfaces of our code. To that end, we'll be covering five main topics:</p>

<ol>
	<li>The restrictions and benefits of functional programming</li>
	<li>The Basics of FP</li>
	<li>More Basics of FP</li>
	<li>Burritos</li>
	<li>Moving From OOP to FP</li>
</ol>

<p>&nbsp;</p>

<section data-type="sect1" id="the-restrictions-and-benefits-of-functional-programming-xYuofr">
<h1>The Restrictions and Benefits of Functional Programming</h1>

<p>Generally speaking, programming within a functional paradigm requires a bit structure than a typical JavaScript programmer might be used to. With that structure comes certain guarantees and challenges. In this section, we'll explore some of the basic tradeoffs in attempting a functional style.</p>

<section data-type="sect2" id="restrictions-GPuLHvfN">
<h2>Restrictions</h2>

<p>Here's a common piece of code that is often trotted out to denigrate programming in a non-functional style:</p>

<pre data-type="programlisting">
x = 1;
x = x + 1;&nbsp;
</pre>

<p>That's it. It might seem pretty innocent, but there are many problems here. Many JavaScript programmers will be fine with this. Some would just be bothered by the first assignment not being preceded by a <code>var</code> to scope within a function. Other people would want a <code>let</code> to scope at the block level. As we've discussed earlier in the book, what we really want here is a <code>const</code>, which would prevent the reassignment on the second line. On a chalkboard in a math class, this would look especially ludicrous.</p>

<p>We covered earlier how reassignment makes programs more complicated to deal with. But reassignment goes a bit deeper than the strictly practical.</p>

<p>If we were thinking of both of these statements as mathematical <em>facts</em>, is <code>x</code> equal to <code>1</code> or does <code>x</code> somehow equal <code>1</code> <em>and</em> <code>1 + 1</code>? Apparently it depends where you are in the program, right? So we can't look at these statements as facts about <code>x</code> anymore. We have <em>variable assignments</em> instead of <em>facts</em> ("values" in functional terms). Values shouldn't change. When they do, our programs look less like math and more like a sequence of instructions.</p>

<p>Ok, so we should be able to solve anyone's objections like this, right?</p>

<pre data-type="programlisting">
const x = 1
const y = x + 1&nbsp;&nbsp;
</pre>

<p>The second problem, and this might seem strange, is that just by having assignments to begin with, we've introduced the concept of <em>time</em> into our program. There is a time before these values exist, and another one after. Yes, our JavaScript programs are steps of execution no matter how we go about it. However, in "declarative programming" of which FP is one type, we seek to de-emphasize those mechanics, instead describing <em>what</em> a program should do, rather than <em>how</em> it should do it. Moreover, assignments in and of themselves are worthless unless they're actually applied to a function (including one that just prints the value of the assignment).</p>

<aside data-type="sidebar" id="spreadsheets-as-declarative-programming-3rsqfJH9fl">
<h5>Spreadsheets as Declarative Programming</h5>

<p>As a simple example of declarative programming, consider a spreadsheet program. Some cells contain data (facts/values). Other cells contain functions to manipulate and use those calculations. Other cells have functions which use the results of executing other functions.</p>

<p>When using a spreadsheet program, we don't really think about the flow of execution of the program. Are the numbers displayed in the cells before they are used in other calculations? If a number is used in multiple calculations, which calculation is executed first?</p>

<p>By the way, if you want to try out a declarative programming language that's especially distant from JavaScript, you should look into Prolog.</p>
</aside>

<p>If worrying about reassignments and even assignments seems really intense, I have bad news, good news, better news, and then some more bad news. The first bit of bad news is that you might find a number of restrictions in a given functional programming language, such as:</p>

<ul>
	<li><em>Variables</em> don't exist. They may be called <em>values</em>, which are constants.</li>
	<li>There is no shared global state (without some difficulty).&nbsp;</li>
	<li>Assignment itself is more complex. Values tend to come from or go into functions.</li>
	<li>Functions should always return something.</li>
	<li><code>if</code> statements without <code>else</code> branches are invalid.</li>
	<li>Functions are declared along with a "type signature" which specify inputs and outputs.</li>
	<li>There is a compilation step where "types" need to line up properly (more on this later).</li>
	<li>The language makes it difficult to use side-effects that may be trivial in other languages.</li>
	<li>There's no concept of <code>null</code>.</li>
</ul>
</section>

<section data-type="sect2" id="benefits-mruVtxf9">
<h2>Benefits</h2>

<p>The good news is that with those restrictions come a ton of benefits. When values only exist in a small scope and can't change, you can trust that a function called with the same arguments always return the same result. This is also called "idempotence," which is <em>half</em> what makes a "pure function." The <em>other half</em> is not producing side-effects.</p>

<p>By this point in the book, functions returning something is an ideal we've been striving for anyways, but what's the benefit of restricting <code>else</code>? If you look at code for an <code>if</code> without an <code>else</code>, you might notice that if will either change the returned value, throw an error or have some other kind of side-effect. In other words, it's a vector for impurity to sneak into our functions.</p>

<p>Because <em>type signatures</em> (we cover them more later, but just think about how we talked about input and output "types" like string and number in Chapter 5) establish what types of values get passed around where, functional purity can be protected at a compilation stage if you have one (and it's nice to find that out then, rather than run-time). In a stricter functional programming language like Haskell, you can have impure functions, but they can be complicated to set up. They could very well take the "<em>fun</em>" out of "<em>fun</em>ctional" for many and make the code "<em>ctional"</em>.</p>

<p>As far as the last one in the bulleted list in the last section, as we talked about before, avoiding <code>null</code> saves us a billion dollars. Of all the restrictions, this is the best. You won't feel restricted while swimming in your Scrooge McDuck vault of gold.</p>

<p>And now, onto the better news. The implications of using pure functions range from convenient to quite compelling. In a stateless world, there is no longer a question of when something happened. If two processing cores of a machine (or more) run the same function, they get the same result, and it doesn't matter which finishes first. In other words, you can avoid <em>race conditions</em>.</p>

<p>Additionally, if functions always return the same thing when called with the same arguments, that means they are "referentially transparent," which means we can substitute the evaluation of the expression with the value produced. Following from that, we (through minor effort in setting up) never have to evaluate a function twice in a row.</p>

<aside data-type="sidebar" id="by-the-way-recursion-ARsDIYtPfn">
<h5>By the way, Recursion</h5>

<p>If you've read this far into the book, you're either familiar with recursion or completely capable of understanding it. We haven't done much with it so far, but it deserves a brief explanation.</p>

<p>If you have a loop, you could likely use recursion instead. For instance, finding an element can be defined iteratively like this:</p>

<pre data-type="programlisting">
function find(toFind, array){
&nbsp; let found = "not found";
&nbsp; array.forEach((element) =&gt; {
&nbsp;&nbsp;&nbsp; if(element == toFind){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; found = "found";
&nbsp;&nbsp;&nbsp; };
&nbsp; });
&nbsp; return found;
};
console.log(find(3, [3, 9, 2])); //found
console.log(find(3, [2, 9, 3])); //found
console.log(find(3, [2, 9, 2])); //not found
</pre>

<p>But we could also have a recursive <code>find</code>:</p>

<pre data-type="programlisting">
function find(toFind, array){
&nbsp; if (array[0] === toFind) {
&nbsp;&nbsp;&nbsp; return "found";
&nbsp; } else if(array.length === 0){
&nbsp;&nbsp;&nbsp; return "not found";
&nbsp; } else{
&nbsp;&nbsp;&nbsp; return find(toFind, array.slice(1));
&nbsp; }
};
console.log(find(3, [3, 9, 2])); //found
console.log(find(3, [2, 9, 3])); //found
console.log(find(3, [2, 9, 2])); //not found
</pre>

<p>There are performance implications with each of these, which we won't get into here, and neither is necessarily the best version of <code>find</code>. This is just to illustrate a couple of things you need for recursive functions.</p>

<p>First, you need a call to a function inside of its declaration (eg. <code>find</code> calls <code>find()</code> inside of itself). Second, you need a "base case," code path (usually prescribed by a conditional) where the function <em>won't call</em> itself. In this case, we have two terminal branches where the function returns <code>"found"</code> or <code>"not found"</code>. If you don't have a base case (or something like a timeout), you will end up with an infinite loop.</p>
</aside>

<p>Back to referential transparency, let's explore this idea with everyone's favorite recursive function, factorial:</p>

<pre data-type="programlisting">
function factorial(number){
  if(number &lt; 2){
    return 1;
  } else {
    return(number * factorial(number - 1));
  }
};
factorial(3); //returns 6
</pre>

<p>That's all well and good, but since we have a pure function (the outputs only depend on the input, we have an opportunity to <em>memoize</em> it.</p>

<pre data-type="programlisting">
const lookupTable = {};
function memoizedFactorial(number){
&nbsp; if(number in lookupTable){
&nbsp;&nbsp;&nbsp; console.log("cached");
&nbsp;&nbsp;&nbsp; return lookupTable[number];
&nbsp; }
&nbsp; else{
&nbsp;&nbsp;&nbsp; console.log("calculating");
&nbsp;&nbsp;&nbsp; var reduceValue;
&nbsp;&nbsp;&nbsp; if(number &lt; 2){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reduceValue = 1;
&nbsp;&nbsp;&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reduceValue = number * memoizedFactorial(number - 1);
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; lookupTable[number] = reduceValue;
&nbsp;&nbsp;&nbsp; return reduceValue;
&nbsp; }
};
console.log(memoizedFactorial(10));// "calculating" 10 times
console.log(memoizedFactorial(10));// "cached" 1 time
console.log(memoizedFactorial(11));// "calculating" (once) and "cached"
</pre>

<p>If we run this example, we'll see that anytime we calculate a value, we add it (along with the <code>number</code> parameter, to the lookup table. The first call <code>memoizedFactorial(10)</code> has to do a bit of work. The second call only needs to reference the lookup table. The third call still has to calculate for <code>11</code>, but <code>10</code> is already a solved problem, so it just pulls that from the <code>lookupTable</code>.</p>

<p>But now our function relies on something other than explicit parameters! It has become impure! How can we avoid it? We need to make the <code>lookupTable</code> an explicit parameter:</p>

<pre data-type="programlisting">
function memoizedFactorial(number, lookupTable = {}){
&nbsp; if(number in lookupTable){
&nbsp;&nbsp;&nbsp; console.log("cached");
&nbsp;&nbsp;&nbsp; return lookupTable[number];
&nbsp; }
&nbsp; else{
&nbsp;&nbsp;&nbsp; console.log("calculating");
&nbsp;&nbsp;&nbsp; var reduceValue;
&nbsp;&nbsp;&nbsp; if(number &lt; 2){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reduceValue = 1;
&nbsp;&nbsp;&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; reduceValue = number * (memoizedFactorial(number - 1, lookupTable))['result'];
&nbsp;&nbsp;&nbsp; };
&nbsp;&nbsp;&nbsp; lookupTable[number] = reduceValue;
&nbsp;&nbsp;&nbsp; return {result: reduceValue, lookupTable: lookupTable};
&nbsp; }
};
console.log(memoizedFactorial(10)['result']);
console.log(memoizedFactorial(10)['result']);
</pre>

<p>If you run this, you'll notice that the cache misses on the second call. This shouldn't be too surprising when you look at what we're calling. We have a default explicit parameter for <code>lookupTable</code> that is an empty object, and we never actually pass it in. No cache means no cache hits.</p>

<p>If we add the following code, we'll see the cache is activated for the second call:</p>

<pre data-type="programlisting">
const lookup = memoizedFactorial(10)['lookupTable'];
memoizedFactorial(10, lookup);
</pre>

<p>There are other ways we could wrap memoization in using functions. Some memoization functions are made to wrap arbitrary functions, but we won't get into that here. In any case, memoization is a useful tool for some situations, but the set up does have some overhead.</p>
</section>

<section data-type="sect2" id="the-future-maybe-of-functional-programming-aOuehefQ">
<h2>The Future (maybe) of Functional Programming</h2>

<p>Let's get back to some more bad news about FP. Some functional concepts are difficult and yet, in the long term, the functional people are probably right. Of all the committees, frameworks, and paradigms influencing JavaScript, the functional ideas are showing a lot of promise, based not only on practical software quality principles, but also they are a lens into the state of hardware today and the future: memory is cheap and computers are parallelizing with multiple cores to avoid keep up with Moore's law. But in order to make use of hardware with multiple processors (or distributed systems), we need code that doesn't care about order of execution so that it can do it in parallel.</p>

<p>It's not hard to see how performance is beginning to become a quality concern. I don't have a crystal ball here, but "you're not writing referentially transparent, pure, functional, concurrent code with compile time type-checking?" becoming the new "you don't write unit tests?" doesn't seem too far fetched.</p>

<p>But the best news, is, throughout the earlier parts of this book, we have already made significant efforts towards many of the good parts of functional programming. Not reassigning variables is definitely something we've been through. Keeping variables scoped tightly and converting between functions and variables are both things we're pretty handy with at this point too. And not every other aspect is terribly difficult. For example, separating pure and impure functions is not too hard if we're already good at extracting functions.</p>
</section>
</section>

<section data-type="sect1" id="the-basics-wrurUr">
<h1>The Basics</h1>

<p>In JavaScript, the benefits and restrictions of programming in functional style are not a simple on and off switch. This is partly because functional style is not rigorously enforced in Javascript, and also because at a basic level, many of the restrictions we can adhere to and the benefits we can enjoy look generically like "better code" rather than "steps toward functional programming." Let's look at a few of those now.</p>

<section data-type="sect2" id="avoiding-destructive-actions-mutation-and-reassignment-mrueHdU9">
<h2>Avoiding Destructive Actions, Mutation, and Reassignment</h2>

<p>When we see a reassignment, we should seek better solutions. For the trivial example below, we would just use <code>const x = 2</code>. A preference of <code>const</code> to <code>let</code> also speaks to this intention as well.</p>

<pre data-type="programlisting">
let x = 1;
x = x + 1;</pre>

<section data-type="sect3" id="avoiding-reassignment-in-conditional-tests-gluOtQHLUw">
<h3>Avoiding Reassignment in Conditional Tests</h3>

<p>Reassignment comes up a lot in conditionals too. See this form:</p>

<pre data-type="programlisting">
function func(x){
  if(x &gt;= 2){
    x = x + 7;
  }
  return x;
};</pre>

<p>But instead we can do this:</p>

<pre data-type="programlisting">
function func(x){
&nbsp;&nbsp;if(x &gt;= 2){
&nbsp;&nbsp;&nbsp; return x + 7;
&nbsp;&nbsp;} else {
  &nbsp; return x;
  }
};

// or

function func(x){
&nbsp; return x &gt;= 2 ? x + 7 : x;
};
</pre>

<p>You might also see (re)assignments in the conditionals themselves:</p>

<pre data-type="programlisting">
function func(x){
&nbsp;&nbsp;if((x = x + 7) &gt;= 9){
&nbsp;&nbsp;&nbsp; return x;
&nbsp;&nbsp;} else {
  &nbsp; return x;
  }
};</pre>

<p>This is a tough one. Reassignment is bad enough, but in conditionals, <em>any</em> assignment can make things a bit more confusing. Not only that, but our else branch returns the original value of <code>x</code> plus seven. In other words, both code paths are the same. Was that obvious to you? Maybe it was, but for me, it takes a minute to realize. Anyways, let's assume that we have tests in place, and our <code>else</code> branch <em>does</em> execute how we want it to.</p>

<p>Where do we go from here? We can start to deal with this by not changing the value of <code>x</code>:</p>

<pre data-type="programlisting">
function func(x){
&nbsp;&nbsp;if((x + 7) &gt;= 9){
&nbsp;&nbsp;&nbsp; return x + 7;
&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp; return x + 7;
&nbsp;&nbsp;}
};</pre>

<p>So now we have repetition, which is ugly, but would be especially bad if instead of <code>+ 7</code>, we had some more expensive call that we had to execute twice. However, something else is made clear by being explicit with the conditionals. We're returning the same thing regardless of input (assuming <code>x</code> is a number), so our function can become this:</p>

<pre data-type="programlisting">
function func(x){
&nbsp; return x + 7;
};</pre>

<p>Did you immediately see this when we had the reassignment in the conditional? If so, awesome. Not everyone will see that clearly though.</p>
Here's another case that is even worse to deal with:

<pre data-type="programlisting">
function func(x, y){
&nbsp; if (x &gt; 1000){
&nbsp;&nbsp;&nbsp; return x;
&nbsp; } else if((x = x + 7) &gt;= 9){
&nbsp;&nbsp;&nbsp; return x;
&nbsp; } else {
&nbsp;&nbsp;&nbsp; return y;
&nbsp; }
};
</pre>

<p>This one is tricky, but let's first remove the reassignment.</p>

<pre data-type="programlisting">
function func2(x, y){
&nbsp; if (x &gt; 1000){
&nbsp;&nbsp;&nbsp; return x;
&nbsp; } else if((x + 7) &gt;= 9){
&nbsp;&nbsp;&nbsp; return x + 7;
&nbsp; } else {
&nbsp;&nbsp;&nbsp; return y;
&nbsp; }
};
</pre>

<p>This has three effects. First, our <code>else if</code> case's <code>return</code> is complicated. Second, we're now doing the <code>+ 7</code> operation twice. That's not a big deal here, but if the calculation was more expensive, we would expect to take a performance hit. Third, the <code>else</code> case has the original value of <code>x</code> as it was passed in. Even though we're not using it, it's good to be aware of that.</p>

<p>To avoid running the function twice, we could set a <code>newX</code> variable immediately:</p>

<pre data-type="programlisting">
function func3(x, y){
&nbsp; const newX = x + 7;
&nbsp; if (x &gt; 1000){
&nbsp;&nbsp;&nbsp; return x;
&nbsp; } else if(newX &gt;= 9){
&nbsp;&nbsp;&nbsp; return newX;
&nbsp; } else {
&nbsp;&nbsp;&nbsp; return y;
&nbsp; }
};
</pre>

<p>This prevents having to execute the <code>+ 7</code> operation twice, but now we're doing it once, even when the <code>if</code> branch is the one we're executing (which doesn't need <code>newX</code> or <code>x</code>). One way of handling this is by introducing a nested <code>if</code> statement:</p>

<pre data-type="programlisting">
function func4(x, y){
&nbsp; if (x &gt; 1000){
&nbsp;&nbsp;&nbsp; return x;
&nbsp; } else {
&nbsp;&nbsp;&nbsp; const newX = x + 7;
&nbsp;&nbsp;&nbsp; if(newX &gt;= 9){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return newX;
&nbsp;&nbsp;&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return y;
&nbsp;&nbsp;&nbsp; }
&nbsp; }
};
</pre>

<p>Now we have three code paths, but we're only doing the <code>x + 7</code> operation once. Even with the extra complexity, you might find this more clear than burying an assingment inside of a conditional. By the way, note that in a more complex/expensive operation than <code>+ 7</code>, our <code>const</code> we might prefer a memoized function here, like this.</p>

<pre data-type="programlisting">
function func5(x, y){
&nbsp; if (x &gt; 1000){
&nbsp;&nbsp;&nbsp; return x;
&nbsp; } else {
&nbsp;&nbsp;&nbsp; if(memoizedAddSeven(x) &gt;= 9){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return memoizedAddSeven(x);
&nbsp;&nbsp;&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return y;
&nbsp;&nbsp;&nbsp; }
&nbsp; }
};</pre>

<p>So we could have a "cache aware function" instead of a "cache variable." This would also let us revert to our simpler form:</p>

<pre data-type="programlisting">
function func6(x, y){
&nbsp; if (x &gt; 1000){
&nbsp;&nbsp;&nbsp; return x;
&nbsp; } else if (memoizedAddSeven(x) &gt;= 9){
&nbsp;&nbsp;&nbsp; return memoizedAddSeven(x);
&nbsp; } else {
&nbsp;&nbsp;&nbsp; return y;
&nbsp; }
};</pre>

<p>Of course, all of what we've done so far has been fairly mechanical. If we actually understand the code, another refactoring would save us from having to mess around with caching variables/functions and ensure we only take the performance hit (albeit a very, very small one for addition in this case) once:</p>

<pre data-type="programlisting">
function func7(x, y){
&nbsp; if (x &gt; 1000){
&nbsp;&nbsp;&nbsp; return x;
&nbsp; } else if (x &gt;= 2){
&nbsp;&nbsp;&nbsp; return x + 7;
&nbsp; } else {
&nbsp;&nbsp;&nbsp; return y;
&nbsp; }
};
</pre>

<p>This change might have been obvious from the start, but refactorings that avoid actually understanding the code are easier to apply in many cases. All that said, odds are if we ended up with a function like this, there's some deeper problem elsewhere in the code. By the way, in this form, we still have have 3 magic numbers and our names for parameters and the function are not descriptive, searchable, or unique.</p>

<aside data-type="sidebar" id="how-overrated-is-understanding-code-dRsvsXtnHAU7">
<h5>How Overrated is Understanding Code?</h5>

<p>It might sound like heresy, but here me out.</p>

<p>It's completely possible to refactor (with tests in place of course) without having a good understanding of what the code actually does. "Digging in" (especially while debugging) is a tremendously important skill, but quality improvements through refactoring do not always demand it. As in our last example, you may hit a point where without having further context, you're stuck, but this is not always the case.</p>

<p>Similarly, when you have a failed test build (or a bad deployment, eek), it's tempting to "dig in" and see what exactly went wrong, but sometimes, it's much faster to just go back to a version of the code that behaved properly, and work from there.</p>

<p>Understanding the code (which includes tracing the execution path, and examining variables and other state at various points in time) is useful but can be tedious. It's important to recognize that it's not the only strategy that works.</p>
</aside>
</section>

<p>&nbsp;</p>

<section data-type="sect3" id="avoiding-reassignment-in-loops-7xuxSgHAUw">
<h3>Avoiding Reassignment in Loops</h3>

<p>Next, let's talk about loops (which frequently have a "loop counter" variable that updates). Instead of using them, we should prefer using <code>forEach</code>, at minimum:</p>

<pre data-type="programlisting">
[3, 4, 2].forEach((element) =&gt; console.log(element));</pre>

<p>This is fine for when we have a simple side effect we want to run, but rather than using a loop (or <code>forEach</code>) to change values inside of an array, we can use <code>map</code> to create a new array with new values.</p>

<pre data-type="programlisting">
[3, 4, 2].map((element) =&gt; element * 2);</pre>

<p>When we want to filter an array to kick some elements out, we can use <code>filter</code>, rather than creating a new array and pushing on the elements that are ok.</p>

<pre data-type="programlisting">
[3, 4, 2].filter((element) =&gt; (element % 2 == 0));</pre>

<p>When we need to transform an array into some other type of value (object, number, etc.), we're likely going to want <code>reduce</code>.</p>

<pre data-type="programlisting">
[3, 4, 2].reduce((element, accumulator) =&gt; element + accumulator);</pre>

<p>In a <code>for</code> loop, any of these functions would tend to work with the index of the loop, as well as an outer variable that reassigns to itself over time. An atomic creation of a new variable makes tests easier keeps values the same.</p>

<p>If you're looking for a good jumping off point for "higher order functions" like these, the <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Array docs</a> are a good place to start.</p>

<aside data-type="sidebar" id="but-you-can-do-anything-with-a-for-loop-REs7uPSpHoUL">
<h5>But you can do anything with a for loop!</h5>

<p>Yes, you can. You can loop through all of your values and build up some other value. You can implement all these with <code>for</code> loop or <code>forEach</code>:</p>

<ul>
	<li><code>every</code></li>
	<li><code>filter</code></li>
	<li><code>find</code></li>
	<li><code>forEach</code> (itself)</li>
	<li><code>map</code></li>
	<li><code>reduce</code>/<code>reduceRight</code></li>
	<li><code>some</code></li>
</ul>

<p>You could also implement them all with <code>reduce</code>, but why would you do either? Use the right tool for the right job. <code>map</code> gives you a new array of transformed elements. <code>every</code>, <code>filter</code>,&nbsp; <code>find</code>, and <code>some</code> return something based on a test conditional you provide.</p>

<p><code>reduce</code> gives you some new value based on your array. It's a bit harder to use than the others, but if you want to get back some accumulated value (a sum/product/object/string/array (that won't work with map)), <code>reduce</code> is what you want. For an easy test of what you want, look above where your loop starts. If it's not the same type as what you're looping through (a number or an empty object usually), you probably want to use <code>reduce</code>.</p>

<p>Using these functions means using functions that take functions as parameters. It might not seem exotic at this point in the book, but it's a good entry point toward exploiting JavaScript's support for 1st class functions (functions as input and output to other functions). Some may argue that that's not "real" functional programming, but will still admit that we're moving closer to a declarative style in contrast with an imperative style. This can be thought of as telling the computer <em>what</em> to do, instead of <em>how</em> to do it.</p>
</aside>
</section>
&nbsp;

<section data-type="sect3" id="avoiding-reassignment-in-conditional-bodies-JDuVTRH2Ue">
<h3>Avoiding Reassignment in Conditional Bodies</h3>

<p>Although we generally have tried to reduce <code>if</code> statements (through polymophism of subclasses, or through delegation to properties) or extracting them to their own named function as a first step, there are places where they will show up in your code. When that happens, try to provide an <code>else</code> case and new variables. So instead of this:</p>

<pre data-type="programlisting">
let emailSubject = "Hi";
if(weKnowName){
  emailSubject = emailSubject + " " + name;
};
sendEmail(emailSubject, emailBody); 
</pre>

<p>Try to do this:</p>

<pre data-type="programlisting">
if(weKnowName){
  let emailSubject = `Hi ${name}`;
} else {
&nbsp;&nbsp;let emailSubject = "Hi";
};
sendEmail(emailSubject, emailBody); 
</pre>

<p>This is much more flexible, as we perceive a few transformations:</p>

<pre data-type="programlisting">
function emailSubject(){
  if(weKnowName){
&nbsp;   let subject = `Hi ${name}`;
  } else {
  &nbsp; let subject = "Hi";
  };
  return subject;
}; 
sendEmail(emailSubject(), emailBody);
</pre>

<p>Then it is clear that we don't need the assignment at all.</p>

<pre data-type="programlisting">
function emailSubject(){
&nbsp;&nbsp;if(weKnowName){
&nbsp;&nbsp;&nbsp; return `Hi ${name}`;
&nbsp;&nbsp;} else {
&nbsp;&nbsp;&nbsp; return "Hi";
&nbsp;&nbsp;};
};
sendEmail(emailSubject(), emailBody);
</pre>

<p>Then, we can simplify the statement with ternary syntax:</p>

<pre data-type="programlisting">
function emailSubject(){
&nbsp; return weKnowName ? `Hi ${name}` : "Hi"
};
sendEmail(emailSubject(), emailBody);
</pre>
</section>

<section data-type="sect3" id="avoiding-destructive-functions-KOu9I8H9Ua">
<h3>Avoiding Destructive Functions</h3>

<p>Another source of mutating values is through using "destructive" functions.</p>

<p>Let's look at splice first:</p>

<pre data-type="programlisting">
const x = [1, 2, 3, 4];
x.splice(1);</pre>

<p><code>splice</code> (with one argument) will start at the index of that argument (the second element in this case), and return the rest of the array. BUT it also updates your array (leaving you with <code>[1]</code>. And because this isn't a reassignment, <code>const</code> doesn't save you from splice's destruction.</p>

<p>Instead of <code>splice</code>, <code>slice</code> will behave itself:</p>

<pre data-type="programlisting">
const z = [1, 2, 3, 4];
z.slice(1);</pre>

<p>This returns <code>[2, 3, 4]</code> also, but doesn't clobber the original <code>z</code> array.</p>

<p>Arrays have destructive functions including <code>fill</code>, <code>push</code>, and <code>pop</code>. <code>Object</code> has <code>defineProperties</code>. Numbers and strings as variables have <code>+=</code> to, respectively, add and concatenate. Arrays have functions (and syntactic sugar, eg. <code>x[0] = "something"</code>) to alter values at particular indices. Objects have <code>Object.assign</code> which mutates the first argument object you give it (you can avoid this by giving it a <code>{}</code> as the first argument), as well as dot (<code>.prop = </code>) and bracket syntax (<code>[prop] =</code>) to alter <em>or</em> create properties.</p>

<p>It might seem crazy to avoid direct assignment, and a good number of functions, just because they are <em>destructive</em>. But you might find it's easier to work with this discipline than to track down a few (or many) rogue global variables that mutate throughout thousands of lines of code.&nbsp;</p>
</section>

<section data-type="sect3" id="avoiding-destruction-in-general-yEuNc3HmUE">
<h3>Avoiding Destruction in General</h3>

<p>Not all functions and convenience syntaxes (such as <code>=</code>) come with a safe version, and <code>const</code> doesn't protect you from mutations (only assignments). So if you want to avoid variables <em>varying</em>, create new variables to pass along. If you want to reassign something, odds are you're wanting something <em>updated value</em>, not just a copy, right? It might as well be a new variable with a new name.</p>

<p>As far as destructive actions (and yes, this includes reassignment and even just <em>assignment</em> when the scope is too large), avoid not only <em>using</em> them (when possible), but also avoid <em>creating</em> functions that are destructive. It is somewhere between odd and worrisome that "Global variables are evil," is seen as common knowledge, but "reassigning variables" don't share that reputation, even though they are two sides of the same coin.</p>

<div data-type="warning" id="databases-are-a-giant-global-variable-6mfGtZczHAU8"><h6>Warning</h6>
<h1>Databases are a Giant Global Variable</h1>

<p>For some reason, most people give databases a free pass as far as global variables go, although there are some promising approaches that treat each moment in time as a distinct "value" for the entire database. Time will tell if those systems become common wisdom at some point.</p>
</div>

<p>Not everyone considers the same things as "destructive." For some people, assignments are fine. For other people, reassigning is fine (ugh). For other people, adding or changing contents of an array or object is fine. For some people, it's an issue of scoping. Even if loop counter variables are unnecessary noise (and we can <em>at least</em> use <code>forEach</code> or other iterable comprehensions instead), some people are fine with variables that update within a loop. Others are fine with reassignments if the variable is only scoped to the function.</p>

<aside data-type="sidebar" id="an-awesome-indicator-of-destruction-0Ds1SdczHgU1">
<h5>An awesome indicator of destruction</h5>

<p>Ruby has a convention (taken from Scheme) to indicate destructive functions with a <code>!</code> after the function name (also <code>?</code> is appended for functions that return a boolean). Although it's not used with terrific consistency, it's a very good idea.</p>

<p>Unfortunately, we don't have that convention, and the interpreters don't allow for it anyways. But given that it is a convention in Ruby that is so widely ignored, it's greatest value might be to you, should you happen to be working on Ruby code, noticing that you may have a capacity to care about something that others seem not to. That's not the same as "mastery" or "intelligence," and certainly not something to berate someone with. But it could help in seeing what library authors care and don't care about these ideas.</p>

<p>Interestingly enough, <code>!</code> and <code>?</code> are used for completely different purposes in the Swift programming language.</p>
</aside>

<p>For this chapter, we're taking a deliberate, hard line and saying destructive actions are not ok. If you <em>really</em> want to avoid state, and have all of the nice things (idempotent, pure functions that can be tested, cached and parallelized easily), this is the price of admission. It might seem like an expensive ticket, but if your choice is this vs. a compiles-to-JS language, this approach is easier. Definitely try out a functional compiles-to-JS or standalone functional language at some point though if you're interested in going from self-discipline to compiler-enforced-discipline.</p>
</section>

<p>&nbsp;</p>
</section>

<section data-type="sect2" id="dont-return-null-aOuVtAUQ">
<h2>Don't return <code>null</code></h2>

<p>Let's look at some code from the last section:</p>

<pre data-type="programlisting">
function emailSubject(){
&nbsp; return weKnowName ? `Hi ${name}` : "Hi"
};
sendEmail(emailSubject(), emailBody);</pre>

<p>If <code>name</code> and <code>nullName</code> were both objects with a defined <code>toHi</code> function:</p>

<pre data-type="programlisting">
const someName = {
  value: "some name",
  toHi(){return `Hi ${this.value}`};
};
const nullName = {
  value: "",
  toHi(){return "Hi"};
};
//assuming getName will get someName or nullName
sendEmail(getName().toHi(), emailBody);</pre>

<p>For further cleanup of this, in Chapter 9, we discussed how we might wrap an object with a Null Object. We'll cover a similar and better (but possibly more complicated) idea later in this chapter.</p>
</section>

<section data-type="sect2" id="referential-transparency-and-avoiding-state-Q8ulhyU3">
<h2>Referential Transparency and Avoiding State</h2>

<p>Here's a question: can data always be the result of a function call? The answer is yes, but any functions relying on or manipulating non-local inputs (free variables) cannot be replaced by their return value without extra consideration. The ability to replace a function call with its return value (without changing the program's behavior) is called <em>referential transparency</em>.</p>

<p>As an example, <code>emailBody</code> in the last section could have also been a call to an <code>emailBody()</code> function, right?</p>

<p>What about this?</p>

<pre data-type="programlisting">
x = 5;</pre>

<p>That could be:</p>

<pre data-type="programlisting">
function five(){ return 5 };
five();</pre>

<p>Or we could just call it right away:</p>

<pre data-type="programlisting">
(() =&gt; 5 )()
</pre>

<p>Or we could return what we pass in instead:</p>

<pre data-type="programlisting">
((x) =&gt; x)(5)</pre>

<p>We can do a similar transformation for functions that actually calculate things.</p>

<pre data-type="programlisting">
3 + 5</pre>

<p>Could be</p>

<pre data-type="programlisting">
(() =&gt; 3)() + (() =&gt; 5)();</pre>

<p>The first function returns 3. The second returns 5. Then they're added.</p>

<pre data-type="programlisting">
((x) =&gt; x)(3) + ((y) =&gt; y)(5);
</pre>

<p>Here a 3 is passed into the first function, which is returned. A 5 is passed into the second function, which is returned. Then the results of those are calculated.</p>

<pre data-type="programlisting">
((x, y) =&gt; x + y)(3, 5)</pre>

<p>If we combine the two expressions, we get this. This might look odd, but it has a few features worth noting. First, the arguments we passed in are only scoped inside of this line. Second, this anonymous IFFE is starting to look a bit like LISP with a few extra bits of syntax. Third, if we assign to what is returned here, we are assigning a numerical value:</p>

<pre data-type="programlisting">
const result = ((x, y) =&gt; x + y)(3, 5);</pre>

<p><code>result</code> is 8. The number. It's not a function. It's the result of a function call. If we're living in a stateless, side-effect free world (although it's also guaranteed by us using only explicit inputs), that means that we could replace any of the above calculations that return <code>8</code> with just an <code>8</code>. And <em>that</em> means, that we can replace any instances of <code>result</code> with <code>8</code>. We never have to do this calculation again with these parameters.</p>

<p>This is referential transparency in action.</p>

<p>And why should the parameters change anyways? Well, let's say we have this situation:</p>

<pre data-type="programlisting">
const recentLogins = ((x, y) =&gt; x + y)(db.loginsToday, 
                                       db.loginsYesterday);</pre>

<p>Now we're looking to the outside world to provide us with values that update in the database. We have a huge ball of state called a database. We don't have to use a database as a place to put lots and lots of variables. Just like in our program, we could be creating new values, rather than updating them.</p>

<pre data-type="programlisting">
const today = //some specific date
const yesterday = //some specific date
const recentLogins = ((x, y) =&gt; x + y)(db.logins(today),
                                       db.logins(yesterday));
</pre>

<p>Disk storage is incredibly cheap, and lookups shouldn't be too bad if you can index by time in your database, (especially given that you should only have to do the lookup once!). Additionally, if you're not overwriting (aka updating, aka throwing away) database information, you should be able to playback the state of your application given a particular query (this also assumes being able to retrieve the version of the code at the same time).</p>

<aside data-type="sidebar" id="arent-we-just-hardcoding-variables-what-about-my-dynamism-rRs8sXhGU6">
<h5>Aren't we just hardcoding variables? What about my dynamism!</h5>

<p>Whenever we introduce a state change, we're creating a concept of time as well. There's a world before the state change, and a world after. Once you destroy information, it's much harder to consider what might have went wrong or restore to a previous state.</p>

<p>Additionally, in high-traffic websites, real-time queries and page loads are optimized for the speed of interface availability*, not the speed of the delivery of every new version of every piece of information in the database. That's why caching exists. Trade-offs are made between delivering something that is not-too-stale but can be not-too-slow to produce. We're not going to get into making <code>recentLogins</code> cache-aware, but the point is that by parameterizing the calls to <code>logins</code> and setting our database up with time in mind, <code>recentLogins</code> has the opportunity to be cached by virtue of it being referentially transparent (for a certain time period). In reality, we'd probably want this to run more than once a day, but letting this (or something much more complex) block showing someone <em>something</em> (even if a few seconds old) is not a good experience.&nbsp;</p>

<p>*Just kidding, websites are mostly prioritized to serve ads, load a large "hero" graphic (or video! how neat!) after a few seconds, and break your ability to fluidly scroll through content of a page.</p>
</aside>

<p>We got a little off track there, but the main point is that nothing has to be in a variable (other than the global defaults) in order to have a working program. Instead of creating objects, we can have functions that <em>store</em> values. Our entire program could be functions wrapping other functions, all kicked off by a single parameter to start the data flowing.</p>

<p>Our program <em>could</em> look a lot like Lisp. Our program <em>could</em> look a lot like XML with parenthesis. This is <em>the</em> concept in Lisp by the way. The AST (abstract syntax tree) to describe how the program works is (in most languages) in a somewhat different form than the source code. In Lisp, it's the same. This is called "homoiconicity."</p>

<p>JavaScript does not share this feature with Lisp, but you can get far closer with some coding styles than others. In any case, there is clearly some link between state, interface, functional programming, and lots of parenthesis that we'll look again. The main point of this section is we have a lot of options and flexibility when it comes to how data enters and is used by our program, and these variations matter beyond syntax.</p>
</section>

<p>&nbsp;</p>

<section data-type="sect2" id="handling-randomness-LRugT8UG">
<h2>Handling Randomness</h2>

<p>In Chapter 4, we dealt with randomness, mostly by avoiding thinking about or testing it. We're not going to go too in depth here either, but in the context of functional programming, we need to address that randomness makes your functions <em>impure</em> (meaning we cannot rely on them to yield the same output when given the same explicit input). In JavaScript, we call <code>Math.random</code> and we get a "random" value. But what we're actually getting is a "pseudo-random" number, which is calculated based on some "seed" value, usually having something to do with time. Unfortunately, this seed value cannot be set in our native <code>Math.random</code> function.</p>

<p>If it could be set with a seed, we could generate the <em>same</em> "random" value sequence. For instance, it could work like this (but not in native JavaScript):</p>

<pre data-type="programlisting">
const mySeed = 3;
let rng = setRng(myseed);
rng.gimmeRandom();
// returns 2593
rng.gimmeRandom();
// returns 8945

rng = setRng(myseed);
rng.gimmeRandom();
// returns 2593
rng.gimmeRandom();
// returns 8945
</pre>

<p>That means that even functions that appear "random" are actually deterministic. This is handy, because you can have random-like numbers that you can test against. It is possible that for your application (or just your tests), this kind of randomness is enough.</p>
</section>

<section data-type="sect2" id="keeping-the-impure-at-bay-7xu4IZUd">
<h2>Keeping the Impure at Bay</h2>

<p>There are three functions in here (not including tests). Can you pick out the impure ones?</p>

<pre data-type="programlisting">
const test = require('tape');
const testdouble = require('testdouble');
var x;

function add(addend1, addend2){
&nbsp; return addend1 + addend2;
};

function setGlobalFromAddition(addend1, addend2){
&nbsp; x = add(addend1, addend2);
}

function readAddition(addend1, addend2, done){
&nbsp; console.log(add(addend1, addend2));
&nbsp; done();
}

test('addition', (assert) =&gt; {
&nbsp; assert.equal(add(2, 3), 5);
&nbsp; assert.end();
});

test('setting global', (assert) =&gt; {
&nbsp; setGlobalFromAddition(2, 3);
&nbsp; assert.equal(x, 5);
&nbsp; assert.end();
});

test('setting global again', (assert) =&gt; {
&nbsp; setGlobalFromAddition(2, 8);
&nbsp; assert.equal(x, 10);
&nbsp; assert.end();
});

test('calling console', (assert) =&gt; {
&nbsp; testdouble.replace(console, 'log');
&nbsp; readAddition(2, 3, () =&gt; {
&nbsp;&nbsp;&nbsp; testdouble.verify(console.log(5));
&nbsp;&nbsp;&nbsp; assert.pass();
&nbsp;&nbsp;&nbsp; testdouble.reset();
&nbsp;&nbsp;&nbsp; assert.end();
&nbsp; });
});
</pre>

<p><code>addition</code> is pure because it only relies on its inputs, and returns an output without having any side-effects. It is also completely trivial to test. Good job <code>addition</code>.</p>

<p>As for the other two, we decided to test them even though they're impure. <code>setGlobalFromAdditon</code> seems like it's easy enough to test. The second and third test run fine. But what if instead of a "dreaded evil global variable," this was a value in a database? And what if other people were testing their code using the same database? Obviously, we should expect occasional failures if we're depending global shared state, and both trying to use the same datastore, right? More realistically, whether it's global state in code or a database, if the amount of tests we need to run are large enough, we're going to want to parallelize our test suite. And then, we will see failures. Impure functions rely on something other than their explicit inputs, and that includes not just non-local variables (and functions if they themselves are impure), but also databases, and the implicit <code>this</code> argument (if it is not immutable). That last one bears repeating, as it is a pretty big shift from how object-oriented programming tends to work: in functional style, we should prefer using explicit inputs and outputs to accessing and modifying a<em> </em><code>this</code> value.</p>

<p>All in all, functions like <code>setGlobalFromAddition</code> will make our testing more difficult. Maybe not immediately, but even without a more complex program that mutates <code>x</code> in multiple places, we already can see tests that cannot be trusted to run in parallel.</p>

<p>The third function, <code>readAddition</code> makes a call to <code>console.log</code>, so it is an impure function with a side-effect in it. The complexities of testing this were explored in the previous chapter, but in the context of this chapter, we have another reason, beyond the mechanics of testing, for why working with this is inconvenient: IO calls are side-effects and make impure functions. Impure functions are hard to test.</p>

<p>If you like, you could try namespacing your impure functions (don't forget to namespace the function calls as well). A simple object would work:</p>

<pre data-type="programlisting">
const impure = {
  setGlobalFromAddition(addend1, addend2){
&nbsp;   x = add(addend1, addend2);
  },
  readAddition(addend1, addend2, done){
&nbsp;   console.log(add(addend1, addend2));
&nbsp;   done();
  }
};</pre>

<p>If you find doing this separation annoying, you really wouldn't like the machinations you have to do to mix pure and impure code in some functional languages (like Haskell).</p>

<p>Through this section, hopefully three things are clear. First, it is easy to tell pure from impure functions. If you know that something will always run the same way, with the same input, and not produce a side effect (meaning anything that doesn't simply return a value), then it is pure. Second, impure functions are harder to test. Third, the simpler (in terms of bulk, inputs, and outputs) your functions are, the better chance they have at being pure.</p>

<p>&nbsp;</p>
</section>

<p>At this point, we've talked over some of the basic hygenic processes you can enact in your code to make it more functional, and also discussed some of the benefits of doing so, including purity, referential transparency, and easier testing. The approaches we've taken, and goals for the code are not unlike those found in the rest of the book. We've already covered a preference for less bulky functions with few inputs and one clear return value. We've also covered why array comprehensions make more sense than <code>for</code> loops. Reassigning variables has been advised against plenty of times earlier.</p>

<p>Now that we have a new perspective on some of our earlier concepts, it's time to branch out. Next we'll be looking at some features that can give us more functional interfaces.</p>

<p>&nbsp;</p>
</section>

<p>&nbsp;</p>

<section data-type="sect1" id="advanced-basics-mru3F6">
<h1>Advanced Basics</h1>

<p>In this section, we'll be exploring some fundamental aspects of functional programming that are still foreign to many JavaScript programmers:</p>

<ul>
	<li>Currying</li>
	<li>Partial Application</li>
	<li>Function Composition</li>
	<li>Types</li>
</ul>

<div data-type="note" id="what-you-cant-get-from-just-plain-javascript-ZGfNtdF7"><h6>Note</h6>
<h1>What you can't get from just plain JavaScript</h1>

<p>Having a compilation step and a type safety system in place (which JavaScript doesn't) are actually pretty handy. Using a compiles-to-js language like TypeScript or Flow will help you realize some of those benefits. Alternatively, you could just go straight for Haskell, Clojure or Scala.</p>
</div>

<p>&nbsp;</p>

<section data-type="sect2" id="currying-and-partial-application-with-ramdajs-7xuxSoFd">
<h2>Currying and Partial Application (with Ramda.js)</h2>

<p>One functional concept that you can use to make your code more flexible is using currying and partial application. Before explaining those terms in words, let's look at a bit of code.</p>

<pre data-type="programlisting">
function add(numberOne, numberTwo){
  return numberOne + numberTwo;
};
add(1, 2);
// 3</pre>

<p>Our favorite addition function so far. Works beautifully. But some (FP rapscallions) would have you believe that this one is better.</p>

<pre data-type="programlisting">
function add(numberOne, numberTwo){
&nbsp;&nbsp;return function(numberOne){
    numberOne + numberTwo;
  };
};
</pre>

<p>There is some weirdness here:</p>

<pre data-type="programlisting">
console.log(add(1, 2));
// [Function]
</pre>

<p>Did we break our perfectly good addition function? Yes.</p>

<p>Now it just makes a function that doesn't care about that second argument (<code>2</code>) at all. Or does it?</p>

<p>We can still use <code>add</code> like this:</p>

<pre data-type="programlisting">
console.log(add(1)(2));
// 3
</pre>

<p>We just replace the <code>,</code> with <code>)(</code> then we're good. But that doesn't explain how it works or why we'd want to do that.</p>

<p>Ok. So the first thing to notice in our second addition function is that it returns a function. That means that when you run <code>add(1)</code>, you get back a function that is waiting for the <code>2</code> (or something else).</p>

<pre data-type="programlisting">
const incrementer = add(1);
incrementer(2);
// 3
</pre>

<p>Our <code>incrementer</code> is a partially applied function. We took our original function that took two arguments, and partially applied one argument that it needed, creating a new function with reduced <em>arity</em> (the number of arguments something takes, eg. arity of 1 takes 1 argument).</p>

<p>Currying is not the same thing as partial application. This was the partial application part:</p>

<pre data-type="programlisting">
const incrementer = add(1);</pre>

<p>We happened to assign it to a variable, but the partial application was when we did this: <code>add(1)</code>. Currying is what we did when we transformed our normal two parameter function (aka. a "binary" function) into one that took one argument (aka. a "unary" function). What we didn't do, however, was use a <code>curry</code> function to do that. We "curried" it manually. As of right now, we don't have a way to take <em>any</em> function of <em>any</em> arbitrary arity and "curry" it.</p>

<p>For that, we need Ramda. The underscore and lodash libraries do similar things, but Ramda has the coolest name and graphic. Also, underscore doesn't have the <code>curry</code> function. Comparing and contrasting the libraries is an exercise left to the reader. Anywho:</p>

<pre data-type="programlisting">
<strong>npm install ramda</strong>
</pre>

<p>Next, let's try it out:</p>

<pre data-type="programlisting">
R = require('ramda');

function add(numberOne, numberTwo){
&nbsp; return numberOne + numberTwo;
};

const curriedAdd = R.curry(add);

console.log(curriedAdd(1));
console.log(curriedAdd(1)(2));
console.log(curriedAdd(1, 2));
</pre>

<p>It's pretty easy to use. We just require it, write our binary function (takes two arguments) as we normally would, and then <code>R.curry</code> does some magic to it.</p>

<pre data-type="programlisting">
[Function]
3
3</pre>

<p>Our output is better than expected. Where our <em>normal</em> ("uncurried") function would choke on the first one (giving us <code>NaN</code> by adding <code>1</code> to <code>undefined</code>), this gives us a partially applied function. <code>(1)(2)</code> as arguments give us <code>3</code>, just like we got from our manual currying process. As a bonus, the curried function still works with our original arity of 2. Passing two arguments with <code>(1, 2)</code> still works fine!</p>

<p>Also the following works as expected:</p>

<pre data-type="programlisting">
const increment = curriedAdd(1);
console.log(increment(3));
</pre>

<p>How would we have built increment if it wasn't curried. Maybe like this?</p>

<pre data-type="programlisting">
function increment(addend){
&nbsp; return add(addend, 1);
};
console.log(increment(3));
</pre>

<p>It's only two more lines in this case, but what if we had <code>increment</code>, <code>addFive</code>, <code>addTen</code>, and so on. Or what if the implementation was more complex?</p>

<p>In case you're not quite on board with currying, here's another possibility. You know that <code>map</code> function we've been praising throughout the book? What if I told you it wasn't that awesome.</p>

<p>Here's something that works ok.</p>

<pre data-type="programlisting">
const square = (thing) =&gt; thing * thing;

console.log([2, 4, 5].map(square));
</pre>

<p>But what if you want to reuse a <code>mapSquares</code> function? Our data is stuck in front of the dot <code>(.)</code>, so what should we do? Altering <code>Array.prototype</code> is strictly a no no. We could create a new class that <code>extends Array</code>, alter <em>that</em> prototype, and make our <code>[2, 4, 5]</code> an instance of that subclass.</p>

<p>Or we could let Ramda do some work.</p>

<pre data-type="programlisting">
R = require('ramda');
const square = (thing) =&gt; thing * thing;

const mapSquares = R.map(square);
console.log(mapSquares([2, 4, 5]));

console.log(R.map(square, [2, 4, 5]));
</pre>

<p>Ramda's <code>map</code> function is already curried, so we can partially apply <code>square</code> to make <code>mapSquares</code>, later applying the data.</p>

<p>But it also allows for a convenient, two-argument version if we feel like "fully applying" the function all at once.</p>

<p>So that's only two of ramda's functions (<code>curry</code> and <code>map</code>), and we're already seeing more flexible, reusable, and shorter interfaces.</p>

<aside data-type="sidebar" id="what-about-this-gRs8ujSzFw">
<h5>What about <code>this</code>?!</h5>

<p>Isn't <code>this</code> the most important keyword in JavaScript? And now, Ramda is just throwing it away? Without a doubt, <code>this</code> will generate more confusion, questions, blog posts than nearly any other topic, with the possible exceptions of "Prototypes are good/bad," and "What library should I use for X."</p>

<p>But that's not the same as "important." If we can get this kind of flexibility and clarity, and <code>this</code> is our sacrifice. Not only is determining what <code>this</code> is a bit confusing, but it also ties up what could be explicit arguments. Ramda just acts like a namespace, which is closer to how "Real" functional programming works.</p>

<p>I might even go as far as saying that using <code>this</code> makes your functions "impure." If you don't want to, that's alright, but isn't the <code>this</code> context just shared mutable state?</p>
</aside>

<p>&nbsp;</p>
</section>

<section data-type="sect2" id="function-composition-JDuVTOFZ">
<h2>Function Composition</h2>

<p>Ok, so we saw that Ramda was pretty awesome, but odds are it's just slightly better than you think. You might be thinking that lodash and underscore will work just as well for composing functions.</p>

<p>Let's give that a shot with the last example (after you run <strong><code>npm install lodash</code></strong>):</p>

<pre data-type="programlisting">
_ = require('lodash');
const square = (thing) =&gt; thing * thing;

const mapSquares = _.map(square);
console.log(mapSquares([2, 4, 5]));
console.log(_.map(square, [2, 4, 5]));</pre>

<p>Kaboom.</p>

<pre data-type="programlisting">
TypeError: mapSquares is not a function</pre>

<p>We can still do this just fine:</p>

<pre data-type="programlisting">
console.log(_.map([2, 4, 5], square));
</pre>

<p>It works, but wait a second... That's backwards!</p>

<p>Yes it is. And traditional. And that tradition of putting data before the "callback" is an impedance to composing functions. We can fix it:</p>

<pre data-type="programlisting">
function mapSquares(data){
&nbsp; return _.map(data, function(toSquare){
&nbsp;&nbsp;&nbsp; return toSquare * toSquare;
&nbsp; });
}
console.log(mapSquares([2, 4, 5]));
</pre>

<p>Admittedly, we can refactor to:</p>

<pre data-type="programlisting">
function mapSquares(data){
&nbsp; return _.map(data, square);
};
</pre>

<p>And to:</p>

<pre data-type="programlisting">
const mapSquares = (data) =&gt; _.map(data, square);
</pre>

<p>But ugh... before we got away with just this:</p>

<pre data-type="programlisting">
const mapSquares = R.map(square);
</pre>

<aside data-type="sidebar" id="point-free-programming-4dsJtxTKFr">
<h5>Point Free Programming</h5>

<p>In this chapter, we're aiming for "point free" style most of the time. That means not working directly with your inputs. You can apply functions to them, but if you give the input a name (like <code>data</code>), and work with it directly, you've created a "point." The word "point" is related to topology, and not the dot (<code>.</code>) in JavaScript.</p>

<p>In the example of mapSquares above, this one is "pointed"</p>

<pre data-type="programlisting">
const mapSquares = (data) =&gt; _.map(data, square);</pre>

<p>And this is point free:</p>

<pre data-type="programlisting">
const mapSquares = R.map(square);</pre>

<p>It's difficult (maybe impossible) to make all of your functions point free, but attempting to should help make a lot of your function definitions shorter.</p>

<p>Before we leave off point-free style, it's worth noting that not everything will be easy.</p>

<p>Earlier, we had this bit of code:</p>

<pre class="pre" data-type="programlisting">
[3, 4, 2].forEach((element) =&gt; console.log(element));</pre>

<p>It might look like we could just do this instead:</p>

<pre data-type="programlisting">
[3, 4, 2].forEach(console.log);</pre>

<p>But this is actually different. Although we only want to print the number, we'll end up printing:</p>

<pre data-type="programlisting">
3 0 [ 3, 4, 2 ]
4 1 [ 3, 4, 2 ]
2 2 [ 3, 4, 2 ]</pre>

<p>That's the number, the index, and the full array. <code>forEach</code> will supply 3 parameters to a callback function if it wants them. <code>console.log</code> will happily print as many arguments as it is passed. We can make a new function based on log that only uses its first argument:</p>

<pre data-type="programlisting">
const logFirst = (first) =&gt; console.log(first)
[3, 4, 2].forEach(logFirst);
</pre>

<p>This topic goes pretty deep. There are functions to turn any function into a <code>unary</code> function (as we did here) as well as functions of another arity. You can reorder parameters as they come in, create functions that are partially applied with placeholder arguments in arbitrary positions in the function signature.</p>

<p>The bottom line is, if you do a lot of function composition, and strive for point free, odds are that you'll end up fiddling with your parameters a bit.</p>
</aside>

<p>Hopefully, everyone gets together and decides that data first is a problem. But in the mean time, it's just one level of working with data directly when we have the wrong argument order, right? At first, yes. But just like conditionals, <code>null</code> returns, and every kind of bulk in the code, complexity seems to breed when no one's watching. More practically, you'll see more nesting (and data variables) if you compose your functions with a data-first library.</p>

<p>As you add functionality, you'll either be making your code more complex (in the function calls or the function definitions) or you'll be composing new functions. Let's see that in action. If we want to raise everything to the fourth power, we could complicate the function call and be done:</p>

<pre data-type="programlisting">
console.log(R.map(square, R.map(square, [2, 4, 5])));
</pre>

<p>Or we could do something like this:</p>

<pre data-type="programlisting">
function fourthPower(thing){
&nbsp; return square(thing) * square(thing);
};
console.log(R.map(fourthPower, [2, 4, 5]));
</pre>

<p>But Ramda has another trick up its sleeve called <code>compose</code>. Check this out:</p>

<pre data-type="programlisting">
const fourthPower = R.compose(square, square);
console.log(R.map(fourthPower, [2, 4, 5]));
</pre>

<p>And we could combine that with <code>map</code> into a new <code>mapFourthPower</code> as well:</p>

<pre data-type="programlisting">
const mapFourthPower = R.map(fourthPower);
console.log(mapFourthPower([2, 4, 5]));
</pre>

<p>And yes, we could actually compose with <code>console.log</code> as well (if we wanted to log the elements, rather than the array):</p>

<pre data-type="programlisting">
const printFourthPower = R.compose(console.log, square, square);
R.map(printFourthPower, [2, 4, 5]);

// or because map is curried, this works too
R.map(printFourthPower) ([2, 4, 5]);
</pre>

<p>So we can choose tiny function definitions and tiny function calls. At worst, we might end up with a few extra function calls around. Although it might be tempting to just have one long chain of <code>compose</code> and <code>map</code> calls, debugging those can be tough. Ramda helps make functions very easy to create and compose. Even though its easy to chain things together too, it's worth striking a balance of how complex your composed functions should be. Smaller composition functions (just like any smaller function) are easier to test and reuse.</p>

<div data-type="note" id="memoize-revisited-with-ramda-Vkf3HqTjFa"><h6>Note</h6>
<h1>Memoize Revisited with Ramda</h1>

<p>By the way, this is what a memoized factorial function looks like in Ramda:</p>

<pre data-type="programlisting">
var factorial = R.memoize(n =&gt; R.product(R.range(1, n + 1)));
</pre>

<p>Apologies if you spent much time trying to learn the long version.</p>
</div>

<p>Another function you'll see from time to time is called <code>pipe</code>. It works like this:</p>

<pre data-type="programlisting">
var factorial = R.memoize(n =&gt; R.product(R.range(1, n + 1)));
var printFact = R.compose(console.log, factorial);
printFact(3);

// is the same as

var factorial = R.memoize(n =&gt; R.product(R.range(1, n + 1)));
var printFact = R.pipe(factorial, console.log);
printFact(3);
</pre>

<p>All in all, Ramda is great, and it exposes the types of functions that make certain interfaces very simple. If you look at the docs, however, you might be surprised at a few things. One is how gigantic it, and other functional libraries are. A facade (Chapter 9) extracted for beginners would be nice.</p>
</section>

<section data-type="sect2" id="types-the-bare-minimum-KOu9IVFg">
<h2>Types: The Bare Minimum</h2>

<p>Before getting to types, one thing that might seem scary about functional code is that if you don't extract any functions, you could write something like this to accomplish the same work we did in the previous chapter:</p>

<pre data-type="programlisting">
console.log(R.map((thing) =&gt; 
  thing * thing, R.map((thing) =&gt; 
    thing * thing, [2, 4, 5])));
</pre>

<p>And Ramda or not, we've recreated another callback hell (with an unfortunate reuse of a bad variable name and two traversals of the array to boot).</p>

<p>Fortunately, we know how to extract functions whether we're doing FP, OOP, or plain old imperative of coding. Extracting functions (maybe after decent naming) is our first line of defense against confusing and untestable code.</p>

<section data-type="sect3" id="the-case-for-types-elu7S0IxFA">
<h3>The Case for Types</h3>

<p>Functional programming has another defense against confusing code: types. When you pass functions to other functions, and sometimes they return the execution of that function and other times they return a function literal, things can get confusing. If you were writing Haskell, you'd deal with this confusion up front. Unlike JavaScript, Haskell actually cares what arity and types you call functions (or compose them) with. So if you try to compose two functions where one would pass a string to the other which expects a number for input, you'd get a compilation (type) error. Same as if you try to do something else weird like this:</p>

<pre data-type="programlisting">
console.log(Math.random("beaver"));
// returns 0.21801069199039524 (at least this time apparently)
</pre>

<p>Why didn't this raise an error? It was almost as if an occult hand threw away that argument. This is fine in JavaScript. It's normal. No compilation means no compilation error. And there's no runtime error either, because JavaScript functions just don't care what you give them, unless their function bodies have some opinion.</p>

<p>The inconsistencies in basic operations of JavaScript are well documented, and opinions vary on whether all of the weirdness is a comedy or a tragedy. The reliance on either third-party specs or a far too dense, huge, and abstract official spec doesn't help matters.</p>

<p>In any case, what good library writers and third-party documenters of core functionality do is list and describe objects, functions, and other random bits, maybe with a tutorial or two sprinkled in. The most crucial piece of this is describing inputs and outputs for functions.</p>

<p>One could argue that this documentation is necessary work to be done anyways, and therefore, having types of inputs and outputs enforced by the language itself would be a good thing. Since someone has to write it, it might as well be written in the code itself, right?</p>

<p>In Haskell, and appearing more and more frequently in documentation of JavaScript library writers who might wish JavaScript was a little more like Haskell, types are described by the Hindley-Milner type system. Most JavaScript documentation doesn't, but it does show up in the Ramda and Sanctuary (we'll cover this library later) docs.</p>

<p>It looks something like this:</p>

<pre data-type="programlisting">
add :: Number -&gt; Number -&gt; Number</pre>

<p>There is much more to it, but these are the most popular parts. <code>add</code> is the function name, followed by two inputs of type <code>Number</code>, and one output <code>Number</code>. But wouldn't it be clearer like this?</p>

<pre data-type="programlisting">
add :: (Number, Number) -&gt; Number</pre>

<p>In a way, but assuming <code>add</code> is curried (which is a good assumption for Haskell and aspirational JavaScript as used in Ramda), we should think of applying (calling the function with) the first <code>Number</code> as producing a new function which waits for the second number. For example, if we applied a 1, we could have a new function with the type:</p>

<pre data-type="programlisting">
addOne :: Number -&gt; Number</pre>

<p>We covered this earlier when our <code>addition</code> function turned into an <code>addOne</code> function after we only gave it one parameter (a <code>1</code>) instead of two parameters right away. If we give <code>addOne</code> another number, it will output a number.</p>

<p>So there are two points here. The first is that in some programming, the assumed arity (how many parameters are passed in) is <em>one</em>, because things are understood to be curried by default.</p>

<p>The second point is that type declarations don't just document what functions do, they also indicate how functions can collaborate with functions. So if you know that a function produces a number, and use its output as input to a function that takes a string, then you shouldn't be surprised if something goes wrong (a complilation or runtime error in some languages and libraries, or maybe just a confused result in JavaScript).</p>
</section>

<p>&nbsp;</p>

<section data-type="sect3" id="less-intuitive-aspects-of-types-80uqI8I7Fw">
<h3>Less Intuitive Aspects of Types</h3>

<p>On the seemingly less awesome side of type documentation (and code itself), the functional style has a preference for short variable names that can be a bit of a shock. Take a look at the type signature for Haskell's <code>map</code> function:</p>

<pre data-type="programlisting">
map :: (a -&gt; b) -&gt; [a] -&gt; [b]</pre>

<p>The grouping of the parentheses&nbsp;<code>(a -&gt; b)</code> indicates that <code>map</code> takes a function&nbsp; as its first argument, that itself takes one input (<code>a</code>) and has one output (<code>b</code>). <code>map</code> also takes an array of <code>[a]</code>. Then it outputs an array of <code>[b]</code>. The <code>a</code> and <code>b</code> seem like excellent candidates for very bad names (short and non-descriptive), but there is a logic behind them.</p>

<p><code>map</code>'s first parameter is a function that transforms an <code>a</code> into a <code>b</code>. It applies that function to a list full of <code>a</code>, and transforms it into a list of <code>b</code>, which it returns. All it's describing is what <em>needs</em> to remain the same, and what <em>may be</em> different. A function that transforms a number into a boolean must be used to transform a list of numbers into a list of booleans. But <code>map</code> doesn't care what type <code>a</code> and <code>b</code> are specifically.</p>

<p>When you declare a variable or constant, that is different because you're labeling a concept of an actual specific value. Here, the type variables are just indicating what is the same and what is different. This is common with higher order functions like <code>map</code>, where the types <code>a</code> and <code>b</code> actually apply to many types. By contrast, note that in the <code>add</code> function above, the inputs and outputs were specific to a <code>Number</code> type.</p>

<p>It can get a little complicated. This is the type description from the <code>concat</code> function of <code>Maybe</code> in Sanctuary.js:</p>

<pre data-type="programlisting">
Maybe#concat :: Semigroup a =&gt; Maybe a&nbsp;~&gt;&nbsp;Maybe a -&gt; Maybe a</pre>

<p>The <code>Maybe#</code> indicates the <code>this</code> object (an object of type <code>Maybe</code>) that has the <code>concat</code> function available. The <code>Maybe a</code> parts describe normal inputs and outputs, and <code>a</code> type variables could be anything, but they're all the same and wrapped up in <code>Maybe</code>s. This is kind of like what we saw before when list items were wrapped up in arrays with <code>[a]</code> and <code>[b]</code>.</p>

<p>We have two types of arrows in <code>Maybe a ~&gt; Maybe a -&gt; Maybe a</code> though. Working from the right, the last arrow is <code>-&gt;</code>, which isn't new. It's just indicating input headed for output. The first one is <code>~&gt;</code> (squiggly arrow) is indicating an implicit parameter (the <code>this</code>) is also in the mix.</p>

<div data-type="note" id="but-isnt-this-bad-JPf9UyIeI9FV"><h6>Note</h6>
<h1>But isn't <code>this</code> bad?</h1>

<p>Unlike in OOP, in functional programming, it's much more common to avoid <code>this</code> in favor of passing explicit parameters. Where we use <code>this</code> in this chapter, it is used mostly as a way to namespace functions. That goes for <code>R</code> (for Ramda functions) and <code>S</code> (for sanctuary functions and objects).</p>

<p>One key thing to note is that these variables provide a namespace and utility functions, but they aren't intended to hold state "variables" that are changed.</p>

<p>In OOP, stateful objects (with mutable values) are arguably better than scattered non-local variables, but in FP, we should consider <code>R</code> and <code>S</code> to provide the same utility as <em>modules</em>, rather than <em>classes</em> or <em>objects</em>.&nbsp;</p>
</div>

<p>The <code>SemiGroup a =&gt;</code> bit is new. That just means that this function (<code>concat</code> of <code>Maybe</code>) is an implementing a function from the <code>Semigroup</code> typeclass. We're not going to get into typeclasses. There is no decent analogous structure for typeclasses in JavaScript. It could be thought of as an <em>interface</em> in some OOP languages, or as a contract that must be fulfilled. In Chapter 9, we discussed empty parent classes as a faulty but possible demonstration of this idea.</p>
</section>

<p>Anyways, if you spend some time in functional corners of JavaScript, you'll hear types discussed and see functions notated with their type signatures from time to time.</p>
</section>
</section>

<section data-type="sect1" id="burritos-aOuDi9">
<h1>Burritos</h1>

<p>This section is might be about burritos. It might be about something else. I can't explain everything about burritos in a few pages. They're too complex and eating too many at once is a mistake. Indigestion and regurgitation full of new metaphors are both common results.</p>

<p>For the sake of your future investigations, <em>burritos</em> might involve any of the following:</p>

<ul>
	<li>Monoids</li>
	<li>Functors</li>
	<li>Applicatives</li>
	<li>Monads</li>
	<li>Maybe more?!</li>
</ul>

<p>Wow. I get a red underline for each of those as misspellings. We're in serious jargon territory apparently. They're complicated, and if this is your first time with them, no explanation is going to work better than some actual code. And this is why people are so quick to explain these things by analogy, and often call anything related to them "burritos." Sometimes this way of explaining comes from someone who doesn't want to explain everything that leads to the practical stuff they want to cover (like me) or as an out for people who feel they don't know enough about functional programming or deep mathematical category theory to really do the topic justice (like me).</p>

<p>The real problem is, people can "get" the concept of a "queue" (for instance), without much difficulty. It's just one thing that's conceptually easy, and the real-life analogs (ie. lines of people waiting for something) are both clear and indicated by the name of the thing. Same goes for "stack." This is, however, less the case for "Linked Lists" and "Bloom Filters."</p>

<p>Anyways, if you try to understand every burrito-like thing (functional "abstract data types," or, ADTs) at once, you're up against things like this:</p>

<figure id="id-XPIlIDiX"><img alt="" class="ihaskell_diagrampng" src="haskell_diagram.png">
<figcaption><span class="label">Figure 11-1. </span>Haskell Burritos</figcaption>
</figure>

<p><a class="list-padding" href="https://atlas.oreilly.com/oreillymedia/refactoring-javascript/editor/master/haskell_diagram.png">&nbsp; haskell_diagram.png</a></p>

<figure id="id-dkIjfKiQ"><img alt="" class="ifantasy_land_diagrampng" src="fantasy_land_diagram.png">
<figcaption><span class="label">Figure 11-2. </span>The "Fantasy Land" specification, for Burritos in JS</figcaption>
</figure>

<p><a class="list-padding" href="https://atlas.oreilly.com/oreillymedia/refactoring-javascript/editor/master/fantasy_land_diagram.png">&nbsp; fantasy_land_diagram.png</a></p>

<p>So "Monads" are usually the burrito in question. And yes, you could try to start there, but all those arrows in these diagrams point from "simple thing" to "more complex thing," which indicates Monads are pretty complex. So if you want a deep dive into this stuff, try starting at Functor. You can definitely understand that one as easily as a queue or a stack. Basically, a Functor has a <code>map</code> function and some rules. In fact, since you're certainly already using <code>map</code> with arrays, you're not starting from scratch here.</p>

<div data-type="note" id="an-actual-explanation-kqfEFZiq"><h6>Note</h6>
<h1>An Actual Explanation</h1>

<p>So there are these words that fly around like "Functors" and "Monads". They're intimidating at first because they're abstract, and it's common to see them explained in terms of other things you might not understand. They are "abstract data types (ADTs)," just like linked-lists and stacks. They are defined by the operations you can perform on them and rules for how they can be used.</p>

<p>A "stack" isn't a thing you use directly, but you can build something that implements a stack interface (ie. it has <code>push</code> and <code>pop</code> functions), according to the rules of how a stack should behave (ie. it stores things in a "last-in-first-out" kind of way).</p>

<p>Similarly, you can create all the scary seeming functional ADTs (probably using objects in JavaScript's case, but maybe just collections of functions) that implement the interface of "abstract data types" according to their rules.&nbsp;</p>
</div>

<p>Anyways, apologies if this is a let down, but the goal with this section of this chapter is to have some concrete experience with useful functional APIs. If you want some further reading on functional programming and functional ADTs, <a href="http://github.com/evanburchard/burritos">here</a> is a list I'll keep updated with some videos, tutorials and books about burritos as I find them.</p>

<section data-type="sect2" id="introducing-sanctuaryjs-vVu4s1ix">
<h2>Introducing Sanctuary.js</h2>

<p>Speaking of a useful API, try this on the command line:</p>

<pre data-type="programlisting">
<strong>npm install sanctuary</strong></pre>

<p>Then in your program, do this:</p>

<pre data-type="programlisting">
const {create, env} = require('sanctuary');
const S = create({checkTypes: true, env: env});&nbsp;
</pre>

<p>And you're left with an <code>S</code> object. Like other functional libraries, it has a massive interface that might be intimidating. As of this writing, there are over a hundred properties defined on <code>S</code>. A lot of them (<code>compose</code>, <code>inc</code>, <code>pluck</code>, etc.) should look familiar after spending some time with Ramda. There is a bit of a difference however.</p>

<pre data-type="programlisting">
R = require('ramda');
R.add("hello", 3);
// NaN</pre>

<p>With Ramda, adding <code>"hello"</code> and <code>3</code> just returns <code>NaN</code>.</p>

<pre data-type="programlisting">
const {create, env} = require('sanctuary');
const S = create({checkTypes: true, env: env});
S.add("hello", 3); 
</pre>

<p>With Sanctuary, you get this:</p>

<pre data-type="programlisting">
TypeError: Invalid value
add :: FiniteNumber -&gt; FiniteNumber -&gt; FiniteNumber
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^^^^^^^^^^^^
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
1)&nbsp; "hello" :: String
The value at position 1 is not a member of FiniteNumber.
</pre>

<p>And with a stack trace. Sanctuary has run-time type checking errors (for the functions it has defined). That's pretty awesome, but possibly not what you'd want in production. If that's the case, you can initialize it without type checking like this:</p>

<pre data-type="programlisting">
const {create, env} = require('sanctuary');
const S = create({checkTypes: false, env: env});
</pre>

<p>Now Sanctuary won't type check its functions, but be careful:</p>

<pre data-type="programlisting">
S.add('hello', 3)
// 'hello3'</pre>

<p>That's default JS behavior, but Ramda and Sanctuary not being in agreement on non-standard behavior could cause some confusion if you're using both. Also, just like lodash and Ramda have different interfaces (Ramda sensibly puts the function first), Ramda and Sanctuary also don't always have the same functions or the same interfaces for those functions that they share.</p>

<p>Anyways, Sanctuary has a lot of functions that are good for functional programming (like Ramda) and it even has a type checker if we want one. Awesome. Also like Ramda, the parameters for its higher order functions (like <code>find</code> and <code>reduce</code>) also follow the "function-first" idea, so it's easy to compose functions like this:</p>

<pre data-type="programlisting">
const getAThree = S.find(x =&gt; x===3);
</pre>

<p>Or point free:</p>

<pre data-type="programlisting">
const getAThree = S.find(R.equals(3));
</pre>

<p>Either way, we can apply the array to <code>getAThree</code>:</p>

<pre data-type="programlisting">
getAThree([3, 4]);</pre>

<p>And then something weird happens. We don't just "get a three," we get:</p>

<pre data-type="programlisting">
Just(3)</pre>

<p>And for an array without a 3 in it:</p>

<pre data-type="programlisting">
getAThree([8, 4]);</pre>

<p>We get:</p>

<pre data-type="programlisting">
Nothing()</pre>

<div data-type="note" id="sanctuarys-motto-zpfXsvsLio"><h6>Note</h6>
<h1>Sanctuary's Motto</h1>

<p>Sanctuary's Motto is "Refuge from unsafe JavaScript." It prefers giving <code>Nothing</code> and <code>Just</code> rather than <code>null</code>. This might seem awkward to handle, but it's much better than being surprised by "undefined method" errors.</p>
</div>
</section>

<section data-type="sect2" id="the-null-object-pattern-revisited-0auEC9iV">
<h2>The Null Object Pattern, Revisited!</h2>

<p>These <code>Nothing</code> and <code>Just</code> values from Sanctuary should remind us of something. We're actually working with a similar concept as was covered with Null Objects in Chapter 9. <code>Just</code> and <code>Nothing</code> are going to remain a mystery for just a bit longer, but let's see how they might apply to our <code>Person</code>/<code>AnonymousPerson</code> code:</p>

<p>Let's see what we had when we used a decorator to wrap our null objects:</p>

<pre data-type="programlisting">
class Person {
&nbsp; constructor(name){
&nbsp;&nbsp;&nbsp; this.name = new NameString(name);
&nbsp; }
};
class AnonymousPerson extends Person {
&nbsp; constructor(){
&nbsp;&nbsp;&nbsp; super();
&nbsp;&nbsp;&nbsp; this.name = null;
&nbsp; }
};
class NameString extends String{
&nbsp; capitalize() {
&nbsp;&nbsp;&nbsp; return new NameString(this[0].toUpperCase() 
               + this.substring(1));
&nbsp; };
&nbsp; tigerify() {
&nbsp;&nbsp;&nbsp; return new NameString(`${this}, the tiger`);
&nbsp; };
&nbsp; display(){
&nbsp;&nbsp;&nbsp; return this.toString();
&nbsp; };
};
class NullString{
&nbsp; capitalize(){
&nbsp;&nbsp;&nbsp; return this;
&nbsp; };
&nbsp; tigerify() {
&nbsp;&nbsp;&nbsp; return this;
&nbsp; };
&nbsp; display() {
&nbsp;&nbsp;&nbsp; return '';
&nbsp; };
};
function WithoutNull(person){
&nbsp; personWithoutNull = Object.create(person);
&nbsp; if(personWithoutNull.name === null){
&nbsp;&nbsp;&nbsp; personWithoutNull.name = new NullString;
&nbsp; };
&nbsp; return personWithoutNull;
};
</pre>

<p>Not bad. It cost us quite a few lines, but we kept the billion dollar mistake (<code>null</code>) at bay.</p>

<p>But using <code>Just</code> and <code>Nothing</code> provide a really easy way to do this. Here's what our new implementation will look like:</p>

<pre data-type="programlisting">
const {create, env} = require('sanctuary');
const S = create({checkTypes: false, env: env});

class Person {
&nbsp; constructor(name){
&nbsp;&nbsp;&nbsp; this.name = S.Just(name);
&nbsp; }
};
class AnonymousPerson extends Person {
&nbsp; constructor(){
&nbsp;&nbsp;&nbsp; super();
&nbsp;&nbsp;&nbsp; this.name = S.Nothing();
&nbsp; }
};
const capitalize = (string) =&gt; string[0].toUpperCase()
                               + string.substring(1);
const tigerify = (string) =&gt; `${string}, the tiger`;
const display = (string) =&gt; string.toString();
</pre>

<p>Starting from the bottom three functions, instead of messing around with specialty forms of string objects with functions implemented on them, we opt for functions that don't rely on an implicit <code>this</code>, and we'll pass our strings as explicit inputs.</p>

<p>We completely got rid of our <code>String</code> extended classes. Instead of setting the names of our person and anonymous person to a new instance of those extended classes, our constructors assign name to be what we can think of as a <em>wrapped</em> <code>name</code> (for <code>Person</code>) or a <em>wrapped</em> <code>null</code> (for <code>AnonymousPerson</code>).</p>

<p>Unsurprisingly, our original tests will fail:</p>

<pre data-type="programlisting">
test("Displaying a person", (assert) =&gt; {
&nbsp; const personOne = new Person("tony");
&nbsp; assert.equal(personOne.name.capitalize().tigerify().display(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Tony, the tiger');
&nbsp; assert.end();
});
test("Displaying an anonymous person", (assert) =&gt; {
&nbsp; const personTwo = new AnonymousPerson("tony");
&nbsp; assert.equal(WithoutNull(personTwo).name.capitalize().tigerify()
    .display(), '');
&nbsp; assert.end();
});
</pre>

<p>The first failure we get is:</p>

<pre data-type="programlisting">
assert.equal(personOne.name.capitalize().tigerify().display(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ^

TypeError: personOne.name.capitalize is not a function
</pre>

<p>This is because we no longer have a "fluent interface" of string functions returning strings to chain with another function. We need a way to apply a function to a <code>Just</code> or <code>Nothing</code>, then rewraps the value and passes it along. To do this, we use <code>map</code>:</p>

<pre data-type="programlisting">
test("Displaying a person", (assert) =&gt; {
&nbsp; const personOne = new Person("tony");
&nbsp; assert.equal(personOne.name.map(capitalize).map(tigerify)
    .map(display), 'Tony, the tiger');
&nbsp; assert.end();
});
test("Displaying an anonymous person", (assert) =&gt; {
&nbsp; const personTwo = new AnonymousPerson("tony");
&nbsp; assert.equal(personTwo.name.map(capitalize).map(tigerify)
    .map(display), '');
&nbsp; assert.end();
});
</pre>

<p>This is the hard part. When you call <code>map</code> on a <code>Just</code> or a <code>Nothing</code>, the function will apply to the values inside of <code>Just</code>, but <code>Nothing</code> will pay no attention to the function applied through <code>map</code>. <code>Nothing</code> will just pass along another <code>Nothing</code>.</p>

<div data-type="note" id="what-i-thought-map-was-for-iterables-like-array-and-object-8QfpHqCniw"><h6>Note</h6>
<h1>What? I thought <code>map</code> was for iterables like <code>Array</code> and <code>Object</code>?</h1>

<p>That is definitely the case in most programming you'll likely do in JavaScript. However, in functional world, <code>map</code> has another role of applying a function to objects of various kinds. It might be hard to unify the ideas of "mapping over an iterable" vs. "mapping over <code>Just</code> or <code>Nothing</code>," but after working with it a bit, it should be clearer.</p>

<p>If that doesn't make sense, don't worry. For now, it's ok if you think of it as a completely new type of <code>map</code> that has nothing to do with the <code>map</code> that works on iterables. It's a new kind of map that "unwraps, applies a function, and rewraps" <code>Just</code> and <code>Nothing</code>.</p>
</div>

<p>We're getting closer, but our tests now fail like this:</p>

<pre data-type="programlisting">
//for personOne
expected: 'Tony, the tiger'
actual:&nbsp;&nbsp; Just("Tony, the tiger")

//for personTwo
expected: ''
actual:&nbsp;&nbsp; Nothing()
</pre>

<p>Interestingly enough, our display function no longer actually does anything. Mapping over a <code>Just('String')</code> with <code>toString</code> still gives us <code>Just('String')</code>, and <code>Nothing()</code> stays as <code>Nothing()</code> as well. The tests are still failing, but we have a bit less code to deal with:</p>

<pre data-type="programlisting">
...
assert.equal(personOne.name.map(capitalize).map(tigerify), 
  'Tony, the tiger');
...
assert.equal(personTwo.name.map(capitalize).map(tigerify), '');
...
</pre>

<p>So how do we unwrap our <code>Just</code> and <code>Nothing</code>? We can use Sanctuary's <code>S.maybeToNullable</code> function:</p>

<pre data-type="programlisting">
test("Displaying a person", (assert) =&gt; {
&nbsp; const personOne = new Person("tony");
&nbsp; assert.equal(S.maybeToNullable(
                 personOne.name.map(capitalize).map(tigerify)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Tony, the tiger');
&nbsp; assert.end();
});
test("Displaying an anonymous person", (assert) =&gt; {
&nbsp; const personTwo = new AnonymousPerson("tony");
&nbsp; assert.equal(S.maybeToNullable(
                 personTwo.name.map(capitalize).map(tigerify)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '');
&nbsp; assert.end();
});
</pre>

<p>This gets us closer. Our first test passes, but our <code>personTwo</code> test fails like this:</p>

<pre data-type="programlisting">
expected: ''
actual:&nbsp;&nbsp; null</pre>

<p>While <code>S.maybeToNullable</code> unwraps the <code>Just</code> without a problem, it gives us the billion dollar mistake for our <code>Nothing</code>. If you look at what's actually happening it's not too surprising:</p>

<pre data-type="programlisting">
S.maybeToNullable(S.Nothing());</pre>

<p>We should expect that to return <code>null</code>. We will take care of the failing test in a minute, but first "<code>maybeToNullable</code>?" What's a <code>Maybe</code> anyways? Try these:</p>

<pre data-type="programlisting">
Object.getPrototypeOf(S.Just());
Object.getPrototypeOf(S.Nothing());
</pre>

<p>They both return this for their prototype:</p>

<pre data-type="programlisting">
Maybe {
&nbsp; '@@type': 'sanctuary/Maybe',
&nbsp; ap: [Function],
&nbsp; chain: [Function],
&nbsp; concat: [Function],
&nbsp; empty: [Function],
&nbsp; equals: [Function],
&nbsp; extend: [Function],
&nbsp; filter: [Function],
&nbsp; map: [Function],
&nbsp; of: [Function],
&nbsp; reduce: [Function],
&nbsp; sequence: [Function],
&nbsp; toBoolean: [Function],
&nbsp; toString: [Function],
&nbsp; inspect: [Function: inspect] }
</pre>

<p>So <code>Just</code> and <code>Nothing</code> are both some kind of <code>Maybe</code>? Is that a perfect academic description. No. But it's a workable one. Now let's fix the test:</p>

<pre data-type="programlisting">
test("Displaying a person", (assert) =&gt; {
&nbsp; const personOne = new Person("tony");
&nbsp; assert.equal(S.maybeFrom('',
                 personOne.name.map(capitalize).map(tigerify)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Tony, the tiger');
&nbsp; assert.end();
});
test("Displaying an anonymous person", (assert) =&gt; {
&nbsp; const personTwo = new AnonymousPerson("tony");
&nbsp; assert.equal(S.maybeFrom('',
                 personTwo.name.map(capitalize).map(tigerify)),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '');
&nbsp; assert.end();
});</pre>

<p>Now our tests should be passing again!</p>
</section>

<section data-type="sect2" id="functional-refactoring-with-maybe-b9uzHvi9">
<h2>Functional Refactoring with Maybe</h2>

<p>Instead of <code>S.maybeToNullable</code>, we used <code>S.maybeFrom</code> to return a blank string <code>''</code> if the <code>Maybe</code> (<code>Nothing</code> or <code>Just</code>) is a <code>Nothing</code>. If it is a <code>Just</code>, it unwraps the value.</p>

<p>So if both names are actually <code>Maybe</code> all along, can we create the wrapper based on the input? Yes. And if the only difference between a <code>Person</code> and an <code>AnonymousPerson</code> is that they have different name values, we don't actually need the subclass anymore:</p>

<pre data-type="programlisting">
class Person {
&nbsp; constructor(name){
&nbsp;&nbsp;&nbsp; this.name = S.toMaybe(name);
&nbsp; }
};
</pre>

<p>And in our tests, we can declare both objects as a <code>new Person</code>:</p>

<pre data-type="programlisting">
...
&nbsp; const personOne = new Person("tony");
...
&nbsp; const personTwo = new Person(null);
...</pre>

<p>So what does our code look like now?</p>

<pre data-type="programlisting">
const {create, env} = require('sanctuary');
const S = create({checkTypes: false, env: env});

class Person {
&nbsp; constructor(name){
&nbsp;&nbsp;&nbsp; this.name = S.toMaybe(name);
&nbsp; }
};

const capitalize = (string) =&gt; string[0].toUpperCase() 
                               + string.substring(1);
const tigerify = (string) =&gt; `${string}, the tiger`;

const test = require('tape');
test("Displaying a person", (assert) =&gt; {
&nbsp; const personOne = new Person("tony");
&nbsp; assert.equal(S.fromMaybe('', 
    personOne.name.map(capitalize).map(tigerify)),
&nbsp; 'Tony, the tiger');
&nbsp; assert.end();
});
test("Displaying an anonymous person", (assert) =&gt; {
&nbsp; const personTwo = new Person(null);
&nbsp; assert.equal(S.fromMaybe('',
    personTwo.name.map(capitalize).map(tigerify)),
&nbsp; '');
&nbsp; assert.end();
});
</pre>

<p>As far as refactoring, we can <code>compose</code> the <code>capitalize</code> and <code>tigerify</code> functions which simplifies our assertions:</p>

<pre data-type="programlisting">
...
const capitalTiger = S.compose(capitalize, tigerify);
...&nbsp; 
assert.equal(S.fromMaybe('', personOne.name.map(capitalTiger)),
             'Tony, the tiger');
...
assert.equal(S.fromMaybe('', personTwo.name.map(capitalTiger)),
             '');
...
</pre>

<p>But we have more possibilities. In order to not break the second test, only apply this to the first assertion:</p>

<pre data-type="programlisting">
assert.equal(personOne.name.map(capitalize).chain(tigerify),
             'Tony, the tiger');
</pre>

<p>Instead of using two <code>map</code> functions and then wrapping with a <code>fromMaybe</code>, we can use <code>chain</code> to get an unwrapped value back from <code>tigerify</code>. Note that if <code>tigerify</code> itself returned a <code>Maybe</code>, that wouldn't work.</p>

<p>Better yet, we can use chain in combination with our composed <code>capitalTiger</code>:</p>

<pre data-type="programlisting">
assert.equal(personOne.name.chain(capitalTiger), 'Tony, the tiger');
</pre>

<p>By the way, in case you're wondering why we can't just call <code>personOne.name</code> as an argument to the <code>capitalTiger</code> function, here's the issue:</p>

<pre data-type="programlisting">
...
assert.equal(capitalTiger(personOne.name), 'Tony, the tiger');
...

//leads to this error

&nbsp;&nbsp; expected: 'Tony, the tiger'
&nbsp;&nbsp; actual:&nbsp;&nbsp; 'Just("tony"), the tiger'
</pre>

<p><code>capitalTiger</code> is supposed to take a string, not a <code>Maybe</code>. Also, note that the type checker wouldn't save you here, because <code>capitalTiger</code> doesn't have its type declarations registered like the <code>S.</code> functions do.</p>

<p>Anyways, if we want to allow <code>capitalTiger</code> to access the <code>maybe</code>, we can <code>lift</code> it, instead of mapping with <code>personOne.name.map(capitalTiger)</code>.</p>

<pre data-type="programlisting">
...
assert.equal(S.lift(capitalTiger, personOne.name), 'Tony, the tiger');
...
</pre>

<p>This has the same result as the <code>map</code> above, but is conceptually a little different. Instead of mapping over the <code>maybe</code> with an ordinary function, you're promoting your function to work with the <code>maybe</code>. You can think of it as making your function special ("lifted") rather than passing it as a dumb argument to <code>map</code> (which itself is already special).</p>

<p>In either case, you can also call <code>.value</code> on the <code>Just</code> to unwrap the value:</p>

<pre data-type="programlisting">
//take your pick

//map
assert.equal(personOne.name.map(capitalTiger).value,             
             'Tony, the tiger');

//chain (unwraps the value, so no need for .value)
assert.equal(personOne.name.chain(capitalTiger), 'Tony, the tiger');

//lift
assert.equal(S.lift(capitalTiger, personOne.name).value, 
             'Tony, the tiger');

</pre>

<p>As for the second test, we could create <em>another</em> function (probably composed with <code>capitalTiger</code>) that would test for <code>Nothing</code> and give us the empty string, but a better option is just using the lower case <code>S.maybe</code> function.</p>

<p>It takes a value, a function, and a <code>Maybe</code>, and retuns the value when the <code>Maybe</code> is not a <code>Just</code>. Otherwise, it returns the result of the function applied to the <code>Maybe</code>'s value. It's perfect for what we want:</p>

<pre data-type="programlisting">
assert.equal(S.maybe('', capitalTiger, personTwo.name), '');
</pre>

<p>&nbsp;But <code>reduce</code> would also work:</p>

<pre data-type="programlisting">
assert.equal(personTwo.name.reduce(capitalTiger, ''), '');
</pre>

<p>It ignores the function (because it is a <code>Nothing</code>) and returns <code>''</code>.</p>

<p>It's alright if the interfaces provided by Ramda and Sanctuary don't make perfect sense or are overwhelming. We covered a lot of ground here. What's nice is that you can incrementally add this style of programming to <em>your</em> JavaScript. Aside from the type signatures, (which are good to know how to read, but you don't <em>need</em> to write), there's no new syntax to learn, and no compilation step necessary.</p>
</section>

<section data-type="sect2" id="functional-refactoring-with-either-Vduztgi2">
<h2>Functional Refactoring with Either</h2>

<p>If you're not too confused by the <code>Maybe</code>, you might be interested in <code>Either</code>. This section won't go into too much depth on it, but as far as motivation, our last test had this line:</p>

<pre data-type="programlisting">
assert.equal(S.fromMaybe('', personTwo.name.map(capitalTiger)), '');</pre>

<p>The second <code>''</code> makes sense, as that's what we're testing against, but isn't the test a little bit late to be determining our value should change from a <code>Nothing</code> into an empty string? What if we wanted to test it again? Would we have to keep specifying that value? Also, if we want to keep our tests symmetrical, should we really have to specify the empty string for our <code>personOne</code> test as well?</p>

<p>Fortunately, there's a way to specify what we would want our <code>Nothing</code> value to unwrap too before we're unwrapping it. Unfortunately, how to do so is a little complicated. Let's look at the code we would need:</p>

<pre data-type="programlisting">
const {create, env} = require('sanctuary');
const S = create({checkTypes: false, env: env});
const R = require('ramda');

class Person {
&nbsp; constructor(name){
&nbsp;&nbsp;&nbsp; this.name = S.maybeToEither('', S.toMaybe(name));
&nbsp; }
};

const capitalize = (string) =&gt; string[0].toUpperCase()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + string.substring(1);
const tigerify = (string) =&gt; `${string}, the tiger`;

const capitalTiger = S.compose(capitalize, tigerify);

const test = require('tape');
test("Displaying a person", (assert) =&gt; {
&nbsp; const personOne = new Person("tony");
&nbsp; assert.equal(S.either(R.identity, capitalTiger, personOne.name),
              'Tony, the tiger');
&nbsp; assert.end();
});
test("Displaying an anonymous person", (assert) =&gt; {
&nbsp; const personTwo = new Person(null);
&nbsp; assert.equal(S.either(R.identity, capitalTiger, personTwo.name),
               '');
&nbsp; assert.end();
});
</pre>

<p>The new pieces here are:</p>

<ul>
	<li>We're requiring Ramda</li>
	<li>We assign our name property by converting the value to a <code>Maybe</code> and then an <code>Either</code></li>
	<li>Our tests are symmetrical and use <code>S.either</code></li>
</ul>

<p>Let's talk about those second two bullet points. First, this line:</p>

<pre data-type="programlisting">
this.name = S.maybeToEither('', S.toMaybe(name));</pre>

<p>As before, in the non-<code>null</code> case, <code>S.toMaybe</code> makes a <code>Just</code> that holds the <code>name</code> value that we pass in. Then, that <code>Just</code> is converted (through <code>S.maybeToEither</code>) into a <code>Right</code> that also holds the <code>name</code>.</p>

<p>In the <code>null</code> case for <code>name</code>, <code>S.toMaybe</code> creates a <code>Nothing</code>, which is the same as before. Then, <code>S.maybeToEither</code> turns that <code>Nothing</code> into a <code>Left</code>, and unlike <code>Nothing</code>, <code>Left</code> can hold a value. The value that it is set to hold is a blank string <code>''</code>.</p>

<p>Because the <code>Left</code> is holding that value from the beginning, we can pull it out at the end in the same way we can pull out the value from the <code>Right</code>. Namely, with these in the tests:</p>

<pre data-type="programlisting">
assert.equal(S.either(R.identity, capitalTiger, personOne.name), '');
assert.equal(S.either(R.identity, capitalTiger, personTwo.name), '');</pre>

<p>The <code>S.either</code> function says: if it's a <code>Left</code>, apply the 1st paramter function to it (<code>R.identity</code>), and if it's a <code>Right</code>, apply the 2nd parameter function to it (<code>capitalTiger</code>). That's <em>okay</em>, but it's also a bit prescriptive.</p>

<p>With a bit better of an understanding, we can use <code>map</code> instead. <code>Left</code> and <code>Right</code> are both <code>Either</code> sub-types. <code>Left</code> acts a little like <code>Nothing</code>, in that unlike <code>Right</code> (or <code>Just</code>), it will ignore when you try to <code>map</code> functions to it. That means our tests could also be the following:</p>

<pre data-type="programlisting">
assert.equal(personOne.name.map(capitalTiger).value, 'Tony, the tiger');
assert.equal(personTwo.name.map(capitalTiger).value, '');
</pre>

<p>This is more in line with how we expect <code>Left</code> and <code>Right</code> to behave. The <code>Right</code> (our <code>personOne.name</code>) goes along with the <code>map</code>'s function (<code>capitalTiger</code>) in the same way a <code>Just</code> would. The <code>Left</code> (our <code>personTwo.name</code>) disregards the <code>map</code>'s wishes, just like a <code>Nothing</code> would do with <code>map</code>. Unlike <code>Nothing</code>, however, the <code>Left</code> is holding onto a value (just like a <code>Just</code> or a <code>Right</code>). That means we can pull that attribute out with <code>.value</code> for both our <code>Left</code> and our <code>Right</code>.</p>

<p>Note that we couldn't use <code>map</code> followed by <code>.value</code> when <code>personTwo.name</code> was a&nbsp; <code>Nothing</code> because a <code>Nothing</code>'s <code>value</code> is actually <code>undefined</code> in sanctuary.</p>

<p>As a final curiousity, you might think that this is fairly complicated way to get our <code>Left</code> value:</p>

<pre data-type="programlisting">
this.name = S.maybeToEither('', S.toMaybe(name));
</pre>

<p>First we convert to a <code>Maybe</code>, and then to an <code>Either</code>. The reason is that, a <code>Left</code> can hold a value, including <code>null</code>. To illustrate:</p>

<pre data-type="programlisting">
S.Either.of(null)
// returns Right(null) not Left(null)!

vs. 

S.toMaybe(null)
// returns Nothing()</pre>

<p>As of this writing, you'll need to first get a <code>Nothing</code>, and then convert it to a blank string containing <code>Left</code> via:</p>

<pre data-type="programlisting">
S.maybeToEither('', S.toMaybe(name));</pre>

<p>Based on what's in the main branch of Sanctuary, we should be seeing a more direct option that would let you do this: <span class="blob-code-inner"><span class="pl-c"><code>S.toEither('', name)</code></span></span>, but for now (Sanctuary version 0.11.1), we're stuck with the workaround. That said, if you're interested in seeing other functional libraries, <a href="http://folktalejs.org">folktale.js</a> has an <a href="http://docs.folktalejs.org/en/latest/api/data/either/Either.html#data.either.Either.fromNullable">Either.fromNullable</a> function that would be perfect for this.</p>

<p>Before we leave this example completely, notice how short our <code>Maybe</code> and <code>Either</code> versions are in comparison to the Null Object wrapping code we made in Chapter 9.</p>
</section>

<p>&nbsp;</p>
</section>

<section data-type="sect1" id="learning-and-using-burritos-Q8uZsj">
<h1>Learning and Using Burritos</h1>

<p>You might be thinking that there are an enormous amount of ways to use <code>Maybe</code> and <code>Either</code>. And that is true. APIs as big as what <code>Maybe</code> has can be intimidating. If you look at the Sanctuary documentation, you'll see that <code>Maybe</code> implements the following ADTs from the "Fantasy Land" Functional JS Specification:&nbsp; Monoid, Monad, Traversable, Extend. Implementing these also means that Functor, Apply, Applicative, Chain, Foldable, and Semigroup are implemented according to the dependency rules of the Fantasy Land Spec.</p>

<p>The good news is, if you like that sort of thing, <code>Maybe</code> and <code>Either</code> have friends. Promises are similar to what are typically called "Future" or "Task." "List" is not unlike how you might use an array. There are a ton of other structures that implement these ADTs.</p>

<p>A public service announcement: Monads (and their friends from the earlier diagram and paragraph above) are at risk of being fetishized in a way that has been the case for design patterns, data structures, algorithms, and even math itself. Not knowing all of the trivia (let alone the deep mathmatical basis) of monadic laws should not stop you from using useful objects and functions when you find them. "I'm not a math person," and a terribly architected web site making company interviewing with "how do you reverse a linked list?" are evil twins of each other.</p>

<p>Just because in some contexts, blocks of knowledge are unfairly treated as a binary of known or unknown does not mean we should perpetuate that. If you worked through the last section and used the <code>Maybe</code> and <code>Either</code> interfaces, you've used a monad, as well as some other good abstractions. You will never <em>have</em> to make your own (when is the last time you implemented a linked list in JavaScript because Arrays weren't good enough?), but you could. And if you did make your own Maybe, Linked List, AbstractFactoryTemplateErrorDecorator, you could make them correct by someone's definition. You could add a few functions that you like even if they don't fit in with other peoples' ideas. You could leave stuff out. And you could call them burritos if you wanted.</p>

<p>The thing is, you can have objects and functions that don't conform to precise definitions but are still useful. If you're <em>creating</em> them, then the interfaces <em>and</em> laws of what makes a functor vs. an applicative vs. a monad should be important to you. If you're just <em>using</em> them, try things out, but focus on the interfaces and don't get hung up on every definition and law. But if you're interested in writing or using something that conforms to the interfaces and rules of high level functional programming abstractions, you should look into the aforementioned <a href="https://github.com/fantasyland/fantasy-land">Fantasy Land Spec</a>, which break things down into digestible pieces and provides links to <a href="https://github.com/fantasyland/fantasy-land/blob/master/implementations.md">implementations</a> of the spec (that means code you can use).</p>

<p>What's awesome about Haskell (and LISP, and Prolog, and other opinionated languages) is that they force you into a certain frame of mind. Same goes for spreadsheets, calculators, calendars, and so on. What's awesome about JavaScript is that we have a massive platform and can write in so many different ways. We used a couple of really great high-level abstractions, and cut down on earlier code significantly.</p>

<div data-type="note" id="deeper-into-functional-programming-nof6IwsZ"><h6>Note</h6>
<h1>Deeper Into Functional Programming</h1>

<p>If you're looking to get deeper into FP, you might find yourself hitting a wall by only using JS directly or with libraries that don't require a compilation step. For compiles-to-JS languages, you have some interesting options:</p>

<ul>
	<li>TypeScript</li>
	<li>PureScript</li>
	<li>ClojureScript</li>
	<li>Elm</li>
</ul>

<p>If you want to explore FP on its own, without worrying about compiling to JavaScript, then you could look into these:</p>

<ul>
	<li>Haskell</li>
	<li>Scheme/Clojure (Lisp variants)</li>
	<li>Erlang</li>
	<li>Scala</li>
</ul>

<p>As of this writing, there are many other choices out there in both categories, and many more are bound to be developed. The point is that you shouldn't feel restricted by only working in JavaScript. Good ideas come from everywhere. It's not uncommon to see a standard way of working in one language appear as an innovation in another.</p>
</div>
</section>

<p>&nbsp;</p>

<section data-type="sect1" id="moving-from-oop-to-fp-LRu3HR">
<h1>Moving from OOP to FP</h1>

<p>As mentioned before, if you're jumping paradigms like OOP to FP, it's probably much too large of a change to be called refactoring anymore. Despite that, it's likely that you will find working through a similar process helpful: make small steps, keep code changes under version control, keep a passing test suite.</p>

<p>In this section, we'll be returning to our NBC example from chapters 6 and 7, followed by some thoughts on rewrites in general.</p>

<section data-type="sect2" id="return-of-the-naive-bayes-classifier-KOuRtbHg">
<h2>Return of the Naive Bayes Classifier</h2>

<p>Let's breifly return to our Naive Bayes example from chapters 6 and 7. It would be great to show the full process of "restructuring" (perhaps "refactoring" if you're taking a broad view of the term), but there are so many changes, that instead, after the code sample, I'll offer some general advice if you find yourself making a decision to change the code this radically.</p>

<pre data-type="programlisting">
//naive_bayes_functional.js
R = require('ramda');

const smoothing = 1.01;

function wordCountForLabel(testWord, relevantTexts){
&nbsp; const equalsTestword = R.equals(testWord);
&nbsp; return R.filter(equalsTestword, _allWords(relevantTexts)).length;
};

function likelihoodOfWord(word, relevantTexts, numberOfTexts){
&nbsp; return wordCountForLabel(word, 
                           relevantTexts) / numberOfTexts + smoothing;
};

function likelihoodByLabel(label, newWords, trainedSet){
&nbsp; const relevantTexts = textsForLabel(trainedSet.texts, label)
&nbsp; const initialValue = trainedSet.probabilities[label] + smoothing;
&nbsp; const likelihood = R.product(
    newWords.map(newWord =&gt; 
      likelihoodOfWord(newWord, 
                       relevantTexts,
                       trainedSet.texts.length))) * initialValue;
&nbsp; return {[label]: likelihood}
}

function textsForLabel(texts, label){
&nbsp; return R.filter(text =&gt; text.label === label)(texts);
}

function _allWords(theTexts){
&nbsp; return R.flatten(R.pluck('words', theTexts));
};

function addText(words, label, existingText = []){
&nbsp; return R.concat(existingText, [{words: words, label: label}]);
};

function train(allTexts) {
&nbsp; const overTextLength = R.divide(R.__, allTexts.length);
&nbsp; return {texts: allTexts,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; probabilities: R.map(overTextLength, 
                               R.countBy(R.identity,
                                         R.pluck('label', allTexts)))};
};

function classify(newWords, trainedSet){
&nbsp; const labelNames = R.keys(trainedSet.probabilities);
&nbsp; return R.reduce((acc, label) =&gt; 
    R.merge(acc, likelihoodByLabel(label, newWords, trainedSet))
            , {}, labelNames);
};

module.exports = {_allWords: _allWords,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; addText: addText,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; train: train,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; classify: classify}
</pre>

<p>And then the tests:</p>

<pre data-type="programlisting">
//naive_bayes_functional_test.js
const NB = require('./naive_bayes_functional.js');

const wish = require('wish');
describe('the file', () =&gt; {
&nbsp; const english = NB.addText(['a', 'b', 'c', 'd', 'e', 'f', 'g',
                      'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q'],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'yes')
&nbsp; const moreEnglish = NB.addText(['a', 'e', 'i', 'o', 'u'],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'yes', english)
&nbsp; const allTexts = NB.addText(['', &nbsp;&nbsp; &nbsp;'',&nbsp;&nbsp; &nbsp;'', &nbsp;&nbsp; &nbsp;'', &nbsp;&nbsp; &nbsp;'',
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '', &nbsp;&nbsp; &nbsp;'',&nbsp;&nbsp; &nbsp;'',&nbsp;&nbsp; &nbsp;'',&nbsp;&nbsp; &nbsp;''],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'no', moreEnglish)

&nbsp; var trainedSet = NB.train(allTexts);

&nbsp; it('works', () =&gt; {
&nbsp;&nbsp;&nbsp; wish(true);
&nbsp; })
&nbsp; it('classifies', () =&gt;{
&nbsp;&nbsp;&nbsp; const classified = NB.classify(['', '', '', '', '', '', '', '', ''], trainedSet);
&nbsp;&nbsp;&nbsp; wish(classified['yes'] === 1.833745640534112);
&nbsp;&nbsp;&nbsp; wish(classified['no'] === 3.456713680099012);
&nbsp; });
&nbsp; it('number of words', ()=&gt;{
&nbsp;&nbsp;&nbsp; wish(NB._allWords(trainedSet.texts).length === 32);
&nbsp; });

&nbsp; it('label probabilities', ()=&gt;{
&nbsp;&nbsp;&nbsp; wish(trainedSet.probabilities['yes'] === 0.6666666666666666);
&nbsp;&nbsp;&nbsp; wish(trainedSet.probabilities['no'] === 0.3333333333333333);
&nbsp; });
});
</pre>

<p>There are major differences from what we had before. Here are some of them:</p>

<ul>
	<li>The algorithm has been slightly altered, leading to different values for "likelihoods," but should not affect the majority of classification outcomes.</li>
	<li>Rather than exporting a class, we export individual functions.</li>
	<li>There is no <code>this</code> anywhere in the code.</li>
	<li>Because there is no <code>this</code> or other state variables, we have to "carry around" all of the state that we need as return values.</li>
	<li>As a consequence of this, our <code>train</code> and <code>classify</code> functions are now idempotent and pure: Same input, same output. No side effects.</li>
	<li>Every function returns something useful.</li>
	<li>The <code>addText</code> function is also idempotent, but we're passing the return value of the early calls to the later ones. That is how we build the set of data.</li>
	<li>It is shorter, but the Ramda functions make the code fairly dense in places.</li>
	<li>We also dropped the Sets and Maps. It's worth exploring them, but they're not as flexible as Objects and Arrays.</li>
	<li>The module becomes just a namespace. Nothing in it is meant to be mutable, so it doesn't hold any state or data: just functions producing output that is used as input to other functions.</li>
	<li>The FP code is shorter.</li>
	<li>In the end, you'll have code that is focused on explicitly transforming your data, "pipelining" it through different operations, rather than having multiple states on objects.</li>
</ul>

<p>As far as getting to this point, the first thing to know is restructuring from OOP to FP is not easy. Some steps may seem like a step backwards if most of your experience is in moving from procedural to OOP.</p>

<p>In no particular order, here are some of the steps you may find yourself taking:</p>

<ul>
	<li>Have good high-level tests in place. If something stops working undo your changes.</li>
	<li>Make every function that isn't returning anything useful return the main object probably with <code>return this</code> at first.</li>
	<li>Change all of the <code>this</code> references to explicitly refer to the object, like <code>Classifier</code> (in this case).</li>
	<li>Flatten out any objects and sub-objects that you can.</li>
	<li>Move properties out of the objects.</li>
	<li>Replace state variables with queries.</li>
	<li>If you have trouble doing this, consider passing in the old state as part of queries until the state eventually just turns into inputs to functions.</li>
	<li>You'll probably make the code look worse before it looks better, as you will want to bring things out of structure before creating new structure. You might add duplication, pass around more parameters, introduce unnecessary functions and poorly named variables as you go.</li>
</ul>

<aside data-type="sidebar" id="why-didnt-we-compose-more-functions-o2syUotmHj">
<h5>Why didn't we compose more functions?</h5>

<p>There are plenty of ways to combine functions (<code>R.compose</code>, inlining, creating an outer function that takes in all parameters), and it might seem obvious that we could have combined the <code>train</code> function with either the <code>addText</code> function or the <code>classify</code> function.</p>

<p>The first question is why do we need the individual functions as opposed to high-level combined ones? The reason for not combining <code>train</code> and <code>addText</code> is that the interface provided by <code>addText</code> is most useful if used a few times to build a bigger set of data. Training it at the same time would mean repetitious or more complicated calculation. The reason for not combining <code>train</code> and <code>classify</code> is that if the training data set was large enough, it could take a very long time to train. We want to keep that separate as it would be easier to do things like pass it off to a separate process. Also, we were interested in just testing with one classified set. It's useful to not repeat the training step for every test.</p>

<p>But why we didn't make those functions available anyways? To keep the API smaller, simpler, and only provide one reasonable way to use the library.</p>
</aside>

<p>All in all, it's hard to move from structure to structure: possibly harder than moving from unstructured to structured code (either OOP or FP). You can strike a balance between the two approaches, but mutating high-level state (the properties of instances of any objects, sets, maps, etc.) that you introduce is very different than simply relying on input and output.</p>
</section>

<section data-type="sect2" id="on-rewrites-yEuKhRHe">
<h2>On Rewrites</h2>

<p>Keep in mind that moving from OOP to FP is just one type of restructuring. If you're intending to move from one framework to another, a "rewrite" is probably what you'll end up doing. Although it's possible to do this slowly and carefully through a <em>strangler app</em> that slowly takes more and more responsibilities from the <em>legacy app</em>, it's hard to not allow that to lead to a fractured user experience for quite a while.</p>

<p>A full rewrite, where the old app is supported until the new one is "good enough" (unfortunately this is usually pretty ambiguous) is an especially difficult problem for a few reasons:</p>

<ul>
	<li><em>Feature Parity</em> for two apps in different frameworks is hard to define.</li>
	<li>It's easy for design changes and new features to become "essential" to the new app, increasing the scope from "feature parity" to something else.</li>
	<li>A solid, (possibly "phased") cutover plan/upgrade path for all customers should be defined.</li>
	<li>If the new version demands new skills to build, your current team, though experts of the old app, might not have great experience with technologies required for the rewrite.</li>
	<li>"Business rules" that may be faithfully executed in the old app are lost in translation, thought incorrectly to be bugs or details that don't matter.</li>
	<li>Progress can be very difficult to demonstrate.</li>
	<li>It's very difficult to estimate how long a rewrite will take.</li>
</ul>

<p>Overall, restructuring between paradigms and rewriting between frameworks are both very hard. They're not simple, mechanical processes like refactoring can be. On a multi-disciplinary team with various working styles and priorities, rewrites will mean very different things to different people.</p>

<p>The principles of moving in small, confident steps, backed up by tests and version control are helpful. Aside from that, the best thing to do is communicate clearly how long things will take, including admitting when your estimates carry assumptions that may prove to be incorrect. When in doubt, double your estimate, and then triple it.</p>

<aside data-type="sidebar" id="a-rewrite-of-your-own-bRsETRhpHQ">
<h5>A Rewrite of Your Own</h5>

<p>If you're interested in a mini-rewrite project, try moving the Naive Bayes code from OOP to FP style. Or try it moving to FP from the procedural version of the code (before the <code>classifier</code> object sucked in all of the functions). See if your version is similar to that of the previous section. Is it easier to start from scratch or move incrementally? Take a guess at how long it will take, and see how accurate your guess was.</p>
</aside>

<p>&nbsp;</p>

<p>&nbsp;</p>
</section>

<p>&nbsp;</p>

<p>&nbsp;</p>
</section>

<section data-type="sect1" id="wrapping-up-7xuotE">
<h1>Wrapping Up</h1>

<p>In this chapter, we discussed some of the benefits of functional programming, and how a good portion them are realized through practices we've discussed all along: not reusing variables, avoiding shared state, extracting functions, preferring array's higher-order functions to for loops.</p>

<p>We also explored some interfaces and libraries (Ramda and Sanctuary) for functional programming on with good old arrays, as well as maybe, which might be new to you but hopefully finds a place in your toolkit to help squash <code>null</code>, the billion dollar mistake.</p>

<p>Maybe functional programming will be your new favorite paradigm. If so, I'd encourage you to try something stricter like Haskell, but if that gets intimidating or you miss working in the browser, remember that you can explore the concepts and exploit the interfaces of FP in JavaScript with just a few <code>require</code> statements. FP doesn't have to be all or nothing.</p>

<p>It's a huge topic, and in this chapter, we just skim the surface. As to what a path toward learning FP could look like, I recommend the following sequence:</p>

<ul>
	<li>Get familiar with the native JS Array's "higher-order functions" (they take a function as input) such as <code>forEach</code>, <code>map</code>, <code>filter</code>, and <code>reduce</code>.</li>
	<li>Try out a library like underscore or lodash that have many more manipulations than what is provided for in native JavaScript.</li>
	<li>Get used to composing functions and manipulating arguments with Ramda or Sanctuary.</li>
	<li>Use Sanctuary, Ramda-Fantasy, or any number of other implementations of the Fantasy Land Spec that describe burrito like things from the earlier diagrams.</li>
</ul>

<p>Along the way, try these out as well.</p>

<ul>
	<li>Use immutable.js or mori.js to enforce immutability beyond what <code>const</code> and <code>.freeze</code> can offer.</li>
	<li>Try out functional languages that compile to JS.</li>
	<li>Try out functional languages that don't compile to JS.</li>
</ul>
</section>

<p>&nbsp;</p>
</section>

  </body>
</html>
