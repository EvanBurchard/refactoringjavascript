<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Refactoring JavaScript</title>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script>
    <link rel="stylesheet" type="text/css" href="theme/html/html.css">
  </head>
  <body data-type="book">
    <section data-type="chapter" id="which-javascript-are-you-using-B7gs9">
<h1>Which JavaScript Are You Using?</h1>

<p>This might seem like it has an easy answer. How varied can one language be? Well, in JavaScript's case, any of these can greatly impact your tooling and workflows:</p>

<ul>
	<li>Versions and Specifications</li>
	<li>Platforms and Implementations</li>
	<li>Pre-compiled Languages</li>
	<li>Frameworks</li>
	<li>Libraries</li>
	<li>What JavaScript Do You Need?</li>
	<li>What JavaScript Are <em>We</em> Using?</li>
</ul>

<p>These can represent not only a different way of doing things, but also a significant time investment to decide upon, learn to proficiency, and eventually, write fluently. Throughout this chapter, we will explore these complexities in order to uncover what JavaScript we <em>can</em> write, and throughout the rest of the book, we'll get more specific about what JavaScript we <em>should</em> write.</p>

<p>Some of the choices involved in what JavaScript to use will be imposed by the project, some by the framework, and some by your own personal tastes.</p>

<p>Developing coding <em>style</em> is one of the biggest challenges in any language. Because of the complexity and diversity of the JavaScript ecosystem, this can be especially challenging. To become a well-rounded coder, some people recommend learning a new programming language every year. But with JavaScript, you might not even be able to learn every dialect in your whole lifetime. For a lot of languages "learning the language," means being competent with core APIs, resources, and one or two popular extensions/libraries. Applying that same standard to JavaScript leaves many contexts unexplored.</p>

<div data-type="note" id="which-framework-should-i-use-oPf0T2"><h6>Note</h6>
<h1>Which framework should I use?</h1>

<p>This is a perennial question posed by JavaScript developers, and a language specific form of "which language should I learn?" that is probably the biggest question from new developers. The framework treadmill can give programmers a sense that they genuinely need to know everything. Job descriptions with inflated and even contradictory requirements don't help. When it comes to JavaScript, the amount of frameworks, platforms and ultimately distinct types of code you might write varies so much, that some form of this question comes up time and time again.</p>

<p>In the end, you can't possibly learn everything. If you have a job or target job that genuinely requires certain skills, spend your time there first. If you don't have a particular job in mind, find friends and mentors at meetups and follow what they do. If neither of those is the case, and you're concerned with learning something that's interesting to you, just pick one that seems cool* and go as deep as you want, move on, and at some point, consider getting very adept with a handful of technologies.</p>

<p>You can apply this same process (job requirement, what your friends are using, and what you think is cool) to languages, frameworks, testing libraries, or musical instruments. In all of them, go deep occasionally, and, if you'll pardon a bit of crass advice, keep an eye on where the money is.&nbsp;</p>

<p>*"seems cool" might sound vague, and it is. For <em>me</em>, that means finding the most novel or mind-bending technology <em>to me</em>. I'm not likely to learn 14 variants of something that solves the same problem. For others, cool means new and hip. To other people it means popular or lucrative. If you don't know what "seems cool" means to you, solve that by taking shallow trips into a few things rather than spending to much time wondering "which to choose."</p>
</div>

<section data-type="sect1" id="versions-and-specifications-MNs8UZ">
<h1>Versions and Specifications</h1>

<p>If you want to know where JavaScript is, and where it's headed, you should follow what's going on with the "<a href="https://tc39.github.io/ecma262/">ECMAScript specification</a>." Although features of JavaScript can bubble up from libraries and specific implementations, if you are looking for the canonical source of features that are likely to stick around, watch the ECMAScript specification.</p>

<p>Specifically, (as of this writing) the committee responsible for tracking and adopting new features to the spec is called TC39. Spec proposals go through a multi-staged process for adoption. You can track Proposals in all 5 stages (0-4) at this URL:</p>

<p><a href="http://github.com/tc39/proposals">http://github.com/tc39/proposals</a></p>

<p>&nbsp;</p>

<div data-type="note" id="about-strict-mode-mWf7u6U7"><h6>Note</h6>
<h1>About Strict Mode</h1>

<p>Because there are a variety of implementations (mostly browsers) in web usage, and "breaking old websites" is generally seen as a bad thing, JavaScript features are unlikely to be deprecated so much as fall out of favor.</p>

<p>Unfortunately, JavaScript contains certain features that cause unpredictability, and others that hurt performance just by being made available.</p>

<p>There is a safer, faster, opt-in subset of JS that is available to developers scoping files or functions with <code>"use strict"</code>.</p>

<p>It is generally seen as good practice to use strict mode. Some frameworks and precompiled languages include it as part of the build/compilation process. Additionally, the bodies of class expressions and declarations are "use strict" by default.</p>
</div>

<p>That said, following the ECMAScript specs has two major downsides. First, the raw documentation can be intimidating in both size and emphasis. It is generally written for those creating browsers rather than applications or websites. In other words, for most of us mere mortals, it is overkill. Some exposure to it is useful, however for those who might either: enjoy describing the features in a more accessible way through a blog post, or prefer not having to rely on said blog posts as their source of truth.</p>

<p>The second downside is that even when a spec proposal is finalized (stage 4), there is no guarantee that your target implementations (ie. node or your target browsers) have made the functionality described available. The spec is far from hypothetical, however, as the specs are influenced by implementers (eg. browser vendors), and in many cases a particular implementation may have a feature in place before it is even finalized in the spec.</p>

<p>If you are interested in features that a spec makes available, but are not yet supported by your choice implementation, three words you'll want to know are: "shims," "polyfills," and "transpilers." Searching "how do I support 'whatever feature' in 'some platform' (eg. node, firefox, chrome, etc.)" sometimes combined with these terms will likely give you the answer you're looking for.&nbsp;</p>
</section>

<p>&nbsp;</p>

<p>&nbsp;</p>

<section data-type="sect1" id="platforms-and-implementations-wQs1SZ">
<h1>Platforms and Implementations</h1>

<p>When node.js hit the scene, web developers experienced some combination of relief and enthusiasm about the prospect of writing the same language on both the back-end and the front-end. Others lamented the fact that JavaScript could be the language to have such a prominent role.</p>

<p>This promise has seen mixed results. The JavaScript ecosystem has flourished with back end pushing the front end to be treated more like real code (organizationally and paradigmatically), while the pure mass of front end developers available ensured that the back end platforms would always attract fresh and curious contributors.</p>

<p>On the other hand, as of this writing, although attempts have been made, full-stack JavaScript frameworks (sometimes called "isomorphic" for running the same code in two places) have not been as popular among developers as dedicated front end and back end frameworks have been. Whereas within Ruby's Rails and Python's Django, there is a clear hub of framework activity, no "grand unifying framework" has emerged in the vibrant, but volatile JavaScript landscape.</p>

<p>In the browser, JavaScript code naturally gravitates toward the&nbsp; <code>window</code> base object, interactions with the DOM, and other browser/device capabilities. On the server-side of a web app, data management and processing requests are the fundamental concern. Even if the language on the front-end and back-end happens to be "the same," the kinds of code written conform to the task at hand such that they are unlikely to follow similar patterns of code organization.</p>

<p>While the ECMAScript spec determines what features are likely to be implemented and supported, you can only use what is supported by your implementation (or libraries you bring in). What version of node or what version of which browser you're relying on is where the spec meets reality.</p>

<p>For tracking what features are natively available in browsers, <a href="http://caniuse.com">caniuse.com</a> keeps an updated list of what is available with respect to not only JavaScript APIs, but also HTML and CSS. For considering both front-end and back-end implementations, you can find broader feature tracking at <a href="https://kangax.github.io/compat-table/esnext/">kangax.github.io/compat-table/</a></p>

<p>If you're specifically interested in what new ECMA/TC39 proposals are implemented on a given platform, you can filter that table like this: <a href="https://kangax.github.io/compat-table/esnext/">kangax.github.io/compat-table/esnext</a></p>

<p>Implementations of a programming language can be called "run-times" or "installs" as well. Particular versions of JavaScript, especially when implementations exist in a browser, are sometimes referred to as a "JavaScript Engine." As far as versions, in addition to having traditional versioning numbers, the relationship of the version with its release cycle makes it likely to see the term "build" or "release" used to describe where it is in the process. You could see things like "Nightly Build," "Weekly Build," "Stable Release," or "Long Term Support Release."&nbsp;</p>

<p>Experimental features (not from the ECMAScript spec), non-normative features (not specified by the spec), and gaps in the spec vary from browser to browser and build to build. Some features that eventually ended up in a finalized spec existed in libraries or implementations for years prior. Other features inside of implementations whither and deprecate when they are either replaced or ignored by the ECMAScript spec and other implementers.</p>

<p>Some places that JavaScript is popping up don't fit neatly into the language of "platform" or "implementation." JavaScript can be used as the source language for applications running on mobile devices, desktop operating systems, and even microcontrollers.</p>

<p>Although these are all exciting avenues for the ecosystem, keeping track of which JavaScript features are available in each context is, unfortunately, not a trivial task.</p>
</section>

<section data-type="sect1" id="precompiled-languages-4gsbsk">
<h1>Precompiled Languages</h1>

<p>So far, we've seen that implementations, platforms, and each version of the ECMAScript spec all have their own concept of what JavaScript is. So which JavaScript should you write?</p>

<p>First, let's take the simplest case of "compiled" vs. "source" JavaScript: a process called "minification." A "minifier" will compress your code to reduce the size of the file, while leaving the same meaning. In a browser context, this means a smaller download for the website user, and consequently, a faster page load.</p>

<p>However, minification is far from the only use case for compiling JavaScript into other JavaScript. One particularly successful project, Babel.js, began with the purpose of allowing developers to make use of future features of JavaScript by taking as input source code that would potentially not yet work in the target implementation and then compiling it into older syntax with better adoption.</p>

<p>Other pre-compiled languages specifically target a feature set that may not have anything to do with the ECMAScript spec, but still feels JavaScript inspired. Sweet.js allows developers to add new keywords and macros to JavaScript. React.js as a whole is out of scope for this section, but the language often used with it, JSX, is also an precompiled language that reads like a mixture of JavaScript and HTML. As evidence to Babel's expansion, both Sweet.js and JSX are compiled into JavaScript using it.</p>

<p>One interesting effect of the love-hate relationship that many developers have with JavaScript is that it has led to an explosion of libraries, some with a compilation step that defines them as precompiled languages. These aim to treat JavaScript as a "compilation target."</p>

<p>In a rage against curly braces and a (former) lack of classes, CoffeeScript gained popularity as a way to write (preferable to some) code that compiled into JavaScript. Many other pre-compilations take a similar approach: write code the way you want to (either a new or preexisting language) and it will be compiled into JavaScript. Although CoffeeScript has fallen out of favor, other precompiled languages are stepping up to fill in other perceived gaps (or just lack of consistency) in JavaScript.</p>

<p>It would be great to give an overview of all of the languages that compile into JavaScript, but there are 337 of these documented on the <a href="https://github.com/jashkenas/coffeescript/wiki/List-of-languages-that-compile-to-JS">CoffeeScript project's wiki</a> as of this writing. If one needed any more evidence of the importance of JavaScript platforms, the distrust of the language itself, or the complexity of JavaScript's ecosystem, this is a good number to have in mind.</p>
</section>

<section data-type="sect1" id="frameworks-k0slFD">
<h1>Frameworks</h1>

<p>Let's step back to the original question of the chapter: "Which JavaScript Are You Using?"</p>

<p>With our current knowledge of specifications, platforms, implementations, and precompiled languages, we would be able to choose a JavaScript website for whatever browsers we want to target by using supported features. Or we could choose to build a program outside of the browser using node. We could even use an precompiled language to backfill or extend the code we want to write and avoid writing <em>actual</em> JavaScript altogether if we wanted. But frameworks provide for another possibility.</p>

<p>Frameworks can unify platforms and implementations as well as extend the vocabulary of the JavaScript we're using. And if you feel, for some reason, that you don't have quite enough decisions to make in order to determine <em>which JavaScript</em> you're using, frameworks are here to provide you with more choices (please clap).</p>

<aside data-type="sidebar" id="vanillajs-KAIXhxFP">
<h5>Vanilla.js</h5>

<p>A parodic JavaScript framework called "vanilla.js" makes a case for using no framework ("vanilla" is sometimes used as a synonym for "plain" or "unadorned") at all. As standards improve and implementations coalesce around common features, the case seems to get stronger.</p>

<p>On the other hand, a lack of willingness to deprecate confusing, non-standard, and duplicated functionality (looking at you, <code>prototype</code>, <code>__proto__</code>, and <code>Object.getPrototypeOf</code>) guarantee a fractured and sprawling feature set.</p>

<p>Perhaps something like 'use strict' will allow for unification of implementations (and obviation of frameworks) in the future, but I wouldn't bet on it.</p>
</aside>

<p>The jQuery, Ember.js, React, Angular, and so on frameworks are basically super libraries. Many, such as Ember, handle code organization, packaging, distribution, and testing concerns. Some create new syntax for writing html, like Angular. React even contains its own precompiled language (the JSX mentioned earlier) that will not run without compilation.</p>

<p>jQuery's footprint is still keenly felt in many apps. Newcomers find the difference between JavaScript and jQuery to be different enough in syntax and purpose that they still ask which they should learn. This is an evergreen question that any framework (front-end or back-end) will face.</p>

<p>The line between frameworks and libraries is a little murky, but whenever you see this question about a library, that indicates (in addition to a bit of confusion on the part of the questioner) that you are dealing with a framework in that it does not resemble JavaScript enough to be recognizable to the beginner.</p>

<p>The term "framework" is incredibly overloaded. Some frameworks that deal specifically with simplifying and unifying browser interactions, like jQuery, use the term "JavaScript Framework," whereas you might see things like Ember.js referred to as "web frameworks" or "app frameworks." App/Web Frameworks tend to come with their own build/compile step, an app server, a base app structure, and a test runner.</p>

<p>To confuse things further, virtually any library can attach the word "framework" to itself (eg. "testing framework") and appear more important. On the other hand, "Electron," which allows desktop OS apps to be built using HTML, CSS, and JavaScript also uses the word <em>framework</em>, whereas in the taxonomy of this chapter, it is closer to a <em>platform</em> unto itself.</p>

<p>&nbsp;</p>
</section>

<section data-type="sect1" id="libraries-avsgix">
<h1>Libraries</h1>

<p>Regardless of how they call themselves, libraries are generally distinguished from frameworks in that they tend to have a more specialized purpose and be smaller (or at least humbler). As of this writing, Underscore.js calls itself a "...library that provides a whole mess of useful functional programming helpers..."</p>

<p>Which JavaScript are you writing?</p>

<p>So far, you have the choice to target specific platforms and implementations. Additionally, you can decide to use "frameworks" which may simplify processes, unify implementations, enable <code>"use strict"</code>, introduce a build/compile step that may include a precompiled language before the JavaScript is generated.</p>

<p>All that libraries tend to add to this is some combination of more features and possible deprecation of others (ala <code>"use strict"</code>).</p>

<p>&nbsp;</p>
</section>

<section data-type="sect1" id="what-javascript-do-you-need-8zsyIp">
<h1>What JavaScript Do You Need?</h1>

<p>It's a tough question. Here are four things to try.</p>

<p><strong>1. Follow the hype</strong></p>

<p>Honestly, if you're unsure, following the hype is the best thing you can do. Choose popular frameworks. Choose popular libraries. Target the most popular platforms and implementations that make sense for your applications and programs. Having a big community means they will also likely have a decent amount of documentation and example code.</p>

<p><strong>2. Try something obscure</strong></p>

<p>After you're done exploring the most popular options, look for a framework that is unique and helps you think about things in a different way. Look for similarities and differences in the more popular version you tried.</p>

<p><strong>3. Use every tool possible</strong></p>

<p>See how bloated and complicated you can make your testing process by introducing every library you can.</p>

<p><strong>4. Go minimalist</strong></p>

<p>See how far you can get with vanilla.js on a given implementation. After you gain some experience with tooling, it can be refreshing to start fresh, only bringing in tools when they justify themselves. This process is covered when we gradually introduce a testing framework in chapter 4.</p>

<p>&nbsp;</p>
</section>

<section data-type="sect1" id="what-javascript-are-we-using-gvsyCA">
<h1>What JavaScript Are <em>We</em> Using?</h1>

<p>With so many options for JavaScript, it might seem impossible to choose any given form for this book. Here's how we're handling that:</p>

<ul>
	<li>No frameworks (except for a few mentions)</li>
	<li>No compilation/transpilation/minifying steps</li>
	<li>Most code is runnable without a browser, using standard node core packages</li>
	<li>A few libraries are brought in for testing (mocha, tape, testdouble, wish)</li>
	<li>Two more are used for functional programming (ramda, sanctuary)</li>
</ul>

<p>As far as style goes, this book is meant to prepare you to adapt and improve upon codebases of varying styles and quality. We'll explore procedural programming, OOP, functional programming.</p>

<p>You will see a lot of bad code <em>before</em> improvements are applied. But the code <em>after</em> might not be optimal, or in your preferred style (or even the author's) either. We take safe, small steps, and in order to demonstrate a wide variety of techniques, not every code snippet can be taken all the way to perfection from its first form.</p>

<p>You'll find the same situation in legacy codebases, and overall, the amount of bad code likely outnumbers the good, both in size and in variations. Through this book, we move <em>incrementally</em> to make things better. There is a temptation when looking at a legacy code base to think "This is garbage. We need to throw it all away and use this framework/style/whatever," but there, you're probably describing a <em>rewrite</em>, which is an ambitious (read "expensive and risky") process. In the styles and changes presented in this book, sometimes we move from bad to ok. Other times from good to better. But through this breadth, we will be exploring a range of options for you to apply to your own work.</p>
</section>

<section data-type="sect1" id="wrapping-up-LesxH4">
<h1>Wrapping Up</h1>

<p>As we covered in this chapter, your options for how to use JavaScript are incredibly broad. This situation may change in the future, but I wouldn't bet too heavily on any <em>one true JavaScript</em>. The ecosystem is so varied that you can explore completely different ways of coding and still stay somewhat close to home. Although "knowing JavaScript" being something of a moving target isn't without its frustrations, the outlook is great for finding new interests and work within JavaScript(s).</p>

<p>&nbsp;</p>
</section>
</section>

  </body>
</html>
