<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Refactoring JavaScript</title>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script>
    <link rel="stylesheet" type="text/css" href="theme/html/html.css">
  </head>
  <body data-type="book">
    <section data-type="chapter" id="refactoring-within-a-hierarchy-wYZsj">
<h1>Refactoring within a Hierarchy</h1>

<p>In the previous two chapters, we saw a large example of refactoring in action. Ultimately, our concern was with the execution of two main actions: training and classifying. It was convenient to write our program as having one main object (a Naive Bayes Classifier), which was also explored as a class and a module.</p>

<p>For this chapter, one object is not enough.</p>

<section data-type="sect1" id="about-crud-apps-and-frameworks-8rsKS0">
<h1>About "CRUD apps" and Frameworks</h1>

<p>As a web application developer, you'd likely spend a lot of time with "CRUD" (create, read, update, delete) applications. That means concentrating on two high-level tasks: organizing data, and presenting that data.</p>

<p>The former is often addressed by database management systems (and your design of the data), while the latter is often handed off to a framework, concerned with the efficient and workable presentation of that data. Database records mix together with some proprietary data, and turn into CSVs and styled web pages.</p>

<p>Although we're not diving into full-stack or presentation frameworks here, it is worth pointing out that they help to avoid a good deal of problems that refactoring helps to solve. These include:</p>

<ul>
	<li>One huge file containing all of the code</li>
	<li>One huge (flat) directory containing all of the code</li>
	<li>One huge object or function containing all of the code</li>
</ul>

<p>As we demonstrated in the pervious chapter, extracting functions, objects, and modules can provide some clarity into how the code works. Frameworks, databases, and other libraries provide common interfaces for data access and presentation, and in doing so, seem to solve the biggest organizational problems.</p>

<p>However, three major drawbacks to frameworks are:</p>

<ul>
	<li>Even if the interface in your app becomes more standardized or "simplified" within a framework, team members will need to come up to speed.</li>
	<li>"Refactoring with framework x" is a rewrite. There's no such thing as "refactoring" by radically changing interfaces.</li>
	<li>Developers can become (or begin as) completely dependent on frameworks, which constrains experience in the language itself.</li>
</ul>

<p>This last point is as troubling as it is common. Many developers can use jQuery/React/etc. to some degree, but struggle with JavaScript outside of those contexts.</p>

<p>In Chapter 6 and 7, we discussed the building blocks of architecting JavaScript in a reasonable way. In this chapter and beyond, we take those ideas a bit further, and in this chapter, we will discuss how hierarchies can go wrong.</p>

<p>There are definitely cases where you will want a framework to help you organize and standardize your code, and but extracting functions, objects, modules, and building hierarchies are all tools that should be considered along with frameworks when you need to manage complexity.</p>
</section>

<p>&nbsp;</p>

<section data-type="sect1" id="lets-build-a-hierarchy-Gqs1fQ">
<h1>Let's Build a Hierarchy</h1>

<p>In this chapter, we'll be dealing with words, specifically, creating a vocabulary list. This could be a simple array of words you need to study, or to add a bit of complexity, words could each be objects with multiple properties: aspects of state (non-function attributes) and behavior (functions).</p>

<p>As far as the motivation for hierarchy, there are two. The first is that having a "parent" <em>object</em> (and possibly <em>class</em> as well), will lend itself to code reuse and less repetition in code. Let's say we want to count the characters of our words, for which we have two classes:</p>

<pre data-type="programlisting">
class EnglishWord{
&nbsp; constructor(word){
&nbsp;&nbsp;&nbsp; this.word = word;
&nbsp; }
&nbsp; count(){
&nbsp;&nbsp;&nbsp; return this.word.length;
&nbsp; }
};
class JapaneseWord{
&nbsp; constructor(word){
&nbsp;&nbsp;&nbsp; this.word = word;
&nbsp; }
&nbsp; count(){
&nbsp;&nbsp;&nbsp; return this.word.length;
&nbsp; }
};
const japaneseWord = new JapaneseWord("犬");
const englishWord = new EnglishWord("dog");
console.log(japaneseWord.word);
console.log(japaneseWord.count());
console.log(englishWord.word);
console.log(englishWord.count());
</pre>

<p>We can see that there is a lot of duplication in the classes, but what can we do about it?</p>

<pre data-type="programlisting">
class Word{
&nbsp; constructor(word){
&nbsp;&nbsp;&nbsp; this.word = word;
&nbsp; }
&nbsp; count(){
&nbsp;&nbsp;&nbsp; return this.word.length;
&nbsp; }
};

class EnglishWord extends Word{};
class JapaneseWord extends Word{};

const japaneseWord = new JapaneseWord("犬");
const englishWord = new EnglishWord("dog");
console.log(japaneseWord.count());
console.log(japaneseWord.word);
console.log(englishWord.count());
console.log(englishWord.word);
</pre>

<p>Now <code>EnglishWord</code> and <code>JapaneseWord</code> both inherit from <code>Word</code>, and the code gets much shorter. We've "extracted a superclass" and "pulled up the functions" from the subclasses. If the subclasses were actually the same, we'd be free to delete those two classes (collapsing the hierarchy) completely and just use <code>new Word("<em>something</em>")</code> for new words. However, we'll be adding distinguishing features to both, so let's keep them for now.</p>

<p>As far as distinguishing features of these different words, they won't tend to appear in the same dictionary. Should we want to look them up, we could add a function to our superclass (<code>Word</code>) like this:</p>

<pre data-type="programlisting">
class Word{
...
&nbsp; lookUp(){
&nbsp;&nbsp;&nbsp; if (this instanceof JapaneseWord){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return `http://jisho.org/search/${this.word}`
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return `https://en.wiktionary.org/wiki/${this.word}`
&nbsp;&nbsp;&nbsp; }
&nbsp; }
};
...
console.log(englishWord.lookUp());
console.log(japaneseWord.lookUp());
</pre>

<p>The <code>instanceof</code> operator is something we haven't seen yet (by the way, the unfortunate lack of camelCase is not a typo). It can be handy, but ties our conditional to a specific name of the class. To get away from that, we might want to add a <code>language</code> attribute to each class of word:</p>

<pre data-type="programlisting">
class Word{
&nbsp; constructor(word){
&nbsp;&nbsp;&nbsp; this.word = word;
&nbsp; }
&nbsp; count(){
&nbsp;&nbsp;&nbsp; return this.word.length;
&nbsp; }
&nbsp; lookUp(){
&nbsp;&nbsp;&nbsp; if (this.language === "Japanese"){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return `http://jisho.org/search/${this.word}`
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return `https://en.wiktionary.org/wiki/${this.word}`
&nbsp;&nbsp;&nbsp; }
&nbsp; }
};

class EnglishWord extends Word{
&nbsp; constructor(word){
&nbsp;&nbsp;&nbsp; super(word);
&nbsp;&nbsp;&nbsp; this.language = "English";
&nbsp; }
};
class JapaneseWord extends Word{
&nbsp; constructor(word){
&nbsp;&nbsp;&nbsp; super(word);
&nbsp;&nbsp;&nbsp; this.language = "Japanese";
&nbsp; }
};

const japaneseWord = new JapaneseWord("犬");
const englishWord = new EnglishWord("dog");
console.log(japaneseWord.count());
console.log(japaneseWord.word);
console.log(englishWord.count());
console.log(englishWord.word);
console.log(englishWord.lookUp());
console.log(japaneseWord.lookUp());
</pre>

<p>Now it might look like our superclass constructor isn't doing very much work. What if we defined each subclass constructor to take over all of the set up responsibilities?</p>

<pre data-type="programlisting">
class EnglishWord extends Word{
&nbsp; constructor(word){
&nbsp;&nbsp;&nbsp; this.word = word;
&nbsp;&nbsp;&nbsp; this.language = "English";
&nbsp; }
};
class JapaneseWord extends Word{
&nbsp; constructor(word){
&nbsp;&nbsp;&nbsp; this.word = word;
&nbsp;&nbsp;&nbsp; this.language = "Japanese";
&nbsp; }
};
</pre>

<p>If we do this, we'll get an error on that third line. Why? It is a weird quirk, but in order to subclass our constructor function, we still need to call <code>super</code>. Otherwise, <code>this</code> is <code>undefined</code>.</p>

<pre data-type="programlisting">
class Word{
&nbsp; count(){
...
&nbsp; }
&nbsp; lookUp(){
...
&nbsp; }
};
class EnglishWord extends Word{
&nbsp; constructor(word){
&nbsp;&nbsp;&nbsp; super();
&nbsp;&nbsp;&nbsp; this.word = word;
&nbsp;&nbsp;&nbsp; this.language = "English";
&nbsp; }
};
class JapaneseWord extends Word{
&nbsp; constructor(word){
&nbsp;&nbsp;&nbsp; super();
&nbsp;&nbsp;&nbsp; this.word = word;
&nbsp;&nbsp;&nbsp; this.language = "Japanese";
&nbsp; }
};
</pre>

<p>Weirder still, is even if the superclass's constructor function is not present at all, we still have to pay it homage. We could split the responsibility like this:</p>

<pre data-type="programlisting">
class Word{
  constructor(word, language){
&nbsp;   this.word = word;
  }
...
};

class EnglishWord extends Word{
&nbsp; constructor(word){
&nbsp;&nbsp;&nbsp; super(word);
    this.language = "English";
&nbsp; }
};
class JapaneseWord extends Word{
&nbsp; constructor(word){
&nbsp;&nbsp;&nbsp; super(word);
&nbsp;&nbsp;&nbsp;&nbsp;this.language = "Japanese";
&nbsp; }
};
</pre>

<p>But it's probably better just to give super all of the responsibility like this:</p>

<pre data-type="programlisting">
class Word{
&nbsp; constructor(word, language){
&nbsp;&nbsp;&nbsp; this.word = word;
&nbsp;&nbsp;&nbsp; this.language = language;
&nbsp; }
...
};
class EnglishWord extends Word{
&nbsp; constructor(word){
&nbsp;&nbsp;&nbsp; super(word, "English");
&nbsp; }
};
class JapaneseWord extends Word{
&nbsp; constructor(word){
&nbsp;&nbsp;&nbsp; super(word, "Japanese");
&nbsp; }
};
</pre>

<aside data-type="sidebar" id="default-parameters-BpHGf0fD">
<h5>Default parameters</h5>

<p>It's totally possible that you find that, most of the time, a parameter to a function (constructor or not) tends to be the same. If that is the case, then you can use default parameters like this:</p>

<pre data-type="programlisting">
class Word{
&nbsp; constructor(word, language="English"){
&nbsp;&nbsp;&nbsp; this.word = word;
&nbsp;&nbsp;&nbsp; this.language = language;
&nbsp; }
...
};
class EnglishWord extends Word{};
class JapaneseWord extends Word{
&nbsp; constructor(word){
&nbsp;&nbsp;&nbsp; super(word, "Japanese");
&nbsp; }
};</pre>

<p>Calling <code>EnglishWord</code>'s constructor will now just use <code>Word</code>'s constructor with one argument (recall that JavaScript doesn't mind when you call too many or too few arguments to a function). By default, the language will be "English," but if a second argument is passed in, the language will be set to whatever that is instead.</p>

<p>Note that this does create some complexity in the function definition, as you have two potential paths instead of one. Additionally, the function calls will not necessarily all look the same.</p>

<p>It's better to use default arguments for something that's truly a default, rather than just a common case. For instance, initially marking a word in a vocab list as <code>studied = false</code> would make sense because it's not possible for it to have been studied before it enters the system.</p>
</aside>

<p>As for the second reason to subclass, let's look again at our <code>lookUp</code> function:</p>

<pre data-type="programlisting">
class Word{
...
&nbsp; lookUp(){
&nbsp;&nbsp;&nbsp; if (this.language === "Japanese"){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return `http://jisho.org/search/${this.word}`
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return `https://en.wiktionary.org/wiki/${this.word}`
&nbsp;&nbsp;&nbsp; }
&nbsp; }
}
</pre>

<p><code>if</code> statements are not universally a bad thing, but better code will tend to avoid them through subclassing or some other mechanism. If we delete the <code>lookUp</code> function from the superclass, and add it to the subclasses, we'll end up with implementations like this:</p>

<pre data-type="programlisting">
class EnglishWord extends Word{
...
&nbsp; lookUp(){
&nbsp;&nbsp;&nbsp; return `https://en.wiktionary.org/wiki/${this.word}`
&nbsp; }
}
class JapaneseWord extends Word{
...
&nbsp; lookUp(){
&nbsp;&nbsp;&nbsp; return `http://jisho.org/search/${this.word}`
&nbsp; }
}
</pre>

<p>This works great, and we have two tiny functions (3 lines each) instead of one small function (5 lines). Overall, we gained a line, but both functions are, independently, simpler to test. Better still, we only have 1 code path for each of them. This may seem subtle, but should either branch grow in complexity, for example, switching dictionaries for different kinds of words (within a language), the complexity will grow in a smaller context. <code>if</code> statements tend to lead to more <code>if</code> statements. Avoiding them helps to keep code bulk down, and subclassing helps to eliminate them.</p>

<p>By the way, notice that if we only had a <code>Word</code> class, and no subclasses, two things are true with our given tools: the conditional check from before is our only option, and we wouldn't be able to use <code>instanceof</code> for that check even if we wanted to.</p>

<div data-type="note" id="subclassing-just-to-avoid-a-conditional-q8CaFDfK"><h6>Note</h6>
<h1>Subclassing? Just to avoid a conditional?</h1>

<p>You may be skeptical of subclassing being the best way to avoid conditionals. Sometimes you'll prefer a simple conditional to subclassing. Other times, you may want to skip both the subclassing and the conditional altogether (see the "State Pattern," covered in Chapter 9).</p>

<p>There are many ways to avoid conditionals, but simplifying functions to not ask "what am I?" type questions are key. This is sometimes called "tell, don't ask."</p>
</div>

<p>You may find that the lookup url itself is valuable. As with the language, there are a few options here. You might change the superclass's implementation of <code>lookUp</code> and just add to the subclassess' constructors:</p>

<pre data-type="programlisting">
class Word{
&nbsp; lookup(){
&nbsp;&nbsp;&nbsp; return this.lookUpUrl + this.word;
&nbsp; }
...
}

class EnglishWord extends Word{
&nbsp; constructor(word){
&nbsp;&nbsp;&nbsp; super(word, "English");
&nbsp;&nbsp;&nbsp; this.lookUpUrl = 'https://en.wiktionary.org/wiki/'
&nbsp; }
}
class JapaneseWord extends Word{
&nbsp; constructor(word){
&nbsp;&nbsp;&nbsp; super(word, "Japanese");
&nbsp;&nbsp;&nbsp; this.lookUpUrl = 'http://jisho.org/search/'
&nbsp; }
}
</pre>

<p>Additionally, you could, as we did with <code>language</code>, add another parameter (<code>lookUpUrl</code>) to the superclass's constructor:</p>

<pre data-type="programlisting">
class Word{
&nbsp; constructor(word, language, lookUpUrl){
&nbsp;&nbsp;&nbsp; this.word = word;
&nbsp;&nbsp;&nbsp; this.language = language;
&nbsp;&nbsp;&nbsp; this.lookUpUrl = lookUpUrl;
&nbsp; }
...
}
class EnglishWord extends Word{
&nbsp; constructor(word){
&nbsp;&nbsp;&nbsp; super(word, 'English', 'https://en.wiktionary.org/wiki/');
&nbsp; }
}
class JapaneseWord extends Word{
&nbsp; constructor(word){
&nbsp;&nbsp;&nbsp; super(word, 'Japanese', 'http://jisho.org/search/');
&nbsp; }
}
</pre>

<p>My take on this is either make the super class do as much as possible, or as little as possible. Having the subclasses simply delegate to the superclass is fairly clean. Having the subclasses each handle as much as possible themselves (and potentially, not even having a constructor superclass) is also fairly clean. Mixing the two together, creating too much variation the constructors of sibling classes (like <code>EnglishWord</code> and <code>JapaneseWord</code>), having default parameters, or relying on deeper hierarchies (eg. <code>super</code>'s <code>super</code>'s <code>super</code>'s constructor) can all make things a bit more confusing.</p>
</section>

<section data-type="sect1" id="lets-wreck-our-hierarchy-ZZsYc6">
<h1>Let's wreck our Hierarchy</h1>

<p>Now that we have a nice hierarchy set up, let's break it down, exploring the following options:</p>

<ul>
	<li>constructor functions</li>
	<li>object literals</li>
	<li>factory functions</li>
</ul>

<section data-type="sect2" id="constructor-functions-0KsmSocz">
<h2>Constructor Functions</h2>

<p>&nbsp;</p>

<pre data-type="programlisting">
function Word(word, language, lookUpUrl){
&nbsp; this.word = word;
&nbsp; this.language = language;
&nbsp; this.lookUpUrl = lookUpUrl;
&nbsp; this.count = function(){
&nbsp;&nbsp;&nbsp; return this.word.length;
&nbsp; }
&nbsp; this.lookUp = function(){
&nbsp;&nbsp;&nbsp; return this.lookUpUrl + this.word;
&nbsp; }
}

function EnglishWord(word){
&nbsp; Word.call(this, word, "English", 'https://en.wiktionary.org/wiki/');
}

function JapaneseWord(word){
&nbsp; Word.call(this, word, "Japanese", 'http://jisho.org/search/');
}


JapaneseWord.prototype = Object.create(Word.prototype);
JapaneseWord.prototype.constructor = JapaneseWord;
EnglishWord.prototype = Object.create(Word.prototype);
EnglishWord.prototype.constructor = EnglishWord;
</pre>

<p>Note that instead of relying on the constructor so heavily, we could have also let the subclass-like constructor functions do more work, as in the following:</p>

<pre data-type="programlisting">
function Word(){
&nbsp; this.count = function(){
&nbsp;&nbsp;&nbsp; return this.word.length;
&nbsp; }
&nbsp; this.lookUp = function(){
&nbsp;&nbsp;&nbsp; return this.lookUpUrl + this.word;
&nbsp; }
}

function EnglishWord(word){
&nbsp; Word.call(this);
&nbsp; this.word = word;
&nbsp; this.language = "English";
&nbsp; this.lookUpUrl = 'https://en.wiktionary.org/wiki/';
}

function JapaneseWord(word){
&nbsp; Word.call(this);
&nbsp; this.word = word;
&nbsp; this.language = "Japanese";
&nbsp; this.lookUpUrl = 'http://jisho.org/search/';
}

EnglishWord.prototype = Object.create(Word.prototype);
EnglishWord.prototype.constructor = EnglishWord;
JapaneseWord.prototype = Object.create(Word.prototype);
JapaneseWord.prototype.constructor = JapaneseWord;
</pre>

<p>This should all look fairly familiar except for the last 4 lines. If we had them, all of our tests and logging statements using the interfaces we've dealt with would pass fine without these lines. However, they are important for establishing the object hierarchy. if we don't assign the prototype, then any changes we make to <code>Word.prototype</code> will not update its subclass-like objects. For example:</p>

<pre data-type="programlisting">
// With the last 4 lines from previous snippet removed
Word.prototype.reportLanguage = function(){
&nbsp; return `The language is: ${this.language}`;
}
const japaneseWord = new JapaneseWord("犬");
console.log(japaneseWord.reportLanguage());</pre>

<p>This will result in an error, because <code>japaneseWord</code> doesn't know about its ancestry. Adding just the first line would fix this:</p>

<pre data-type="programlisting">
JapaneseWord.prototype = Object.create(Word.prototype);</pre>

<p>However, this confuses a lot of APIs that you might be relying on, including <code>.prototype</code>, <code>.__proto__</code>, <code>.constructor</code>, <code>Object.getPrototypeOf()</code>, and any creational approaches that rely on those mechanisms.</p>

<aside data-type="sidebar" id="which-javascript-is-better-KpHjurSlc0">
<h5>Which JavaScript is Better?</h5>

<p>In JavaScript, anytime you want to know what an object is, what is inside of it, how it came to be, loop through it, or create a new one based on it, you have a lot of bad options.</p>

<p>My general recommendation is to stick to recent sources. You'll see these lean towards two types of people: spec-friendly and purists. If you follow "spec-friendly" people, you'll have decent references for APIs, and you'll see many critiques and questions around the same problems you're having. Following the "purists" also has value, because they do the most questioning, push specs to improve, and spend a lot of time endorsing approaches that work well, even if they may not be as popular. You can learn a lot from them.</p>

<p>As far as inheritance, there has always been a group desperately pushing for OOP, as well as a group embracing the <em>true</em> nature of JavaScript. As of this writing, it seems that both of these groups are somehow paradoxically winning. While that's great, it also adds an extra layer of confusion, especially when you factor in how both approaches may change year by year.</p>
</aside>

<p>&nbsp;</p>
</section>

<section data-type="sect2" id="object-literals-mnsATQcj">
<h2>Object Literals</h2>

<p>Next, we'll turn to another approach we've used before, object literals. Let's start with our "superclass," which in this style, is instead called the "delegate prototype." It's just an object:</p>

<pre data-type="programlisting">
const word = {
&nbsp; count(){
&nbsp;&nbsp;&nbsp; return this.word.length;
&nbsp; },
&nbsp; lookUp(){
&nbsp;&nbsp;&nbsp; return this.lookUpUrl + this.word;
&nbsp; }
};
</pre>

<p>So how do we "inherit" from it? Here is where we get stuck. Should we rely on constructor functions for the "subclasses?"</p>

<p>We don't have to. Here is the simplest approach:</p>

<pre data-type="programlisting">
const englishWord = Object.create(word);
englishWord.word = 'dog';
englishWord.language = 'English';
englishWord.lookUpUrl = 'https://en.wiktionary.org/wiki/';

const japaneseWord = Object.create(word);
japaneseWord.word = '犬';
japaneseWord.language = 'Japanese';
japaneseWord.lookUpUrl = 'http://jisho.org/search/';
</pre>

<p>That seems a little clunky though. We create a copy of the <code>word</code> object with <code>Object.create</code>, but then we have to assign all of our new properties in an awkward way.</p>

<p>Let's try using ES2015's <code>Object.assign</code>:</p>

<pre data-type="programlisting">
const englishWord = Object.assign(Object.create(word),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {word: 'dog',
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  language: 'English',
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lookUpUrl: 'https://en.wiktionary.org/wiki/'})

const japaneseWord = Object.assign(Object.create(word),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {word: '犬',
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  language: 'japanese',
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lookUpUrl: 'http://jisho.org/search/'})
</pre>

<p>That's a little better because now we have one simple statement that combines objects, rather than updating them. Changing values of variables (even members of arrays and objects) is problematic as we saw earlier, so this approach is preferable. By the way, that is also why we're using <code>Object.create(word)</code> instead of just <code>word</code> as the first argument. The first parameter of <code>Object.assign</code> is actually intended to be the "target" object. If we just put <code>word</code> in there, it would clobber our original, rather than giving us a fresh copy to augment.</p>

<p>&nbsp;</p>
</section>

<section data-type="sect2" id="factory-functions-E1spf0cd">
<h2>Factory Functions</h2>

<p>This might seem pretty good so far, but if we're creating a lot of words, these approaches are also clunky as opposed to using the <code>new</code> keyword with either <code>class</code> or a constructor function. What's the alternative?</p>

<p>&nbsp;</p>

<p>We can use "Factory functions" like this:</p>

<pre data-type="programlisting">
const word = {
&nbsp; count(){
&nbsp;&nbsp;&nbsp; return this.word.length;
&nbsp; },
&nbsp; lookUp(){
&nbsp;&nbsp;&nbsp; return this.lookUpUrl + this.word;
&nbsp; }
}
const englishWordFactory = (theWord) =&gt; {
&nbsp; return Object.assign(Object.create(word),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {word: theWord,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; language: 'English',
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lookUpUrl: 'https://en.wiktionary.org/wiki/'})
};

const japaneseWordFactory = (theWord) =&gt; {
&nbsp; return Object.assign(Object.create(word),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {word: theWord,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; language: 'Japanese',
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lookUpUrl: 'http://jisho.org/search/'})
};

const englishWord = englishWordFactory('dog');
const japaneseWord = japaneseWordFactory('犬');
</pre>

<p>Revisiting our entire purpose for subclassing to begin with, we had two main purposes. First, we didn't want to have to repeat code. Second, we wanted to get rid of the if statement. This accomplishes both of those goals (and shaves off 3 lines).</p>

<p>So, what's the downside?</p>

<p>This approach is missing two things as compared with <code>class</code>, constructor functions, and other approaches to "simulate" Object-Oriented Programming. First, when working with bare objects and simple factory functions that return objects, you will lack access to some aspects of "reflection," meaning that seeing what <em>type</em> of object it <em>is</em> and related tasks might lack support. One could argue that these interfaces (such as <code>instanceof</code>, <code>.prototype</code>, <code>Object.getPrototypeOf</code>, <code>.__proto__</code> and friends) are what make the objects simple and clear. On the other hand, the objects are simple enough that they should define themselves fairly clearly instead of the factory method, and those functions aren't all consistent or clear themselves.</p>

<p>Secondly, classes keep your superclass open to extension, so you can easily add functionality to subclasses. Try this at the bottom of the class version of the code:</p>

<pre data-type="programlisting">
const japaneseWord = new JapaneseWord("犬"); //old code

//new code
Word.prototype.reportLanguage = function(){
&nbsp; return `The language is: ${this.language}`;
}
console.log(japaneseWord.reportLanguage());
</pre>

<p>You can do this even after you create the individual words. In our class-free, factory function code, the objects are unavailable for these kinds of late extensions because they have no prototype chain. Note that this ability to track prototypes broke when we started using factory functions, not as a part of us using <code>Object.create</code> or <code>Object.assign</code>.</p>

<p>One could argue that anytime you want new behavior, you should get new objects instead of updating old ones. In any case, here is one way you could achieve the updating with factories:</p>

<pre data-type="programlisting">
const wordFactory = function(){
&nbsp; return {count(){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this.word.length;
&nbsp;&nbsp;&nbsp; },
&nbsp;&nbsp;&nbsp; lookUp(){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return this.lookUpUrl + this.word;
&nbsp;&nbsp;&nbsp; }
&nbsp; }
}

const englishWordFactory = (theWord) =&gt; {
&nbsp; let copy = Object.assign(wordFactory(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {word: theWord,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; language: 'English',
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lookUpUrl: 'https://en.wiktionary.org/wiki/'})
&nbsp; return Object.setPrototypeOf(copy, wordFactory);
}

const japaneseWordFactory = (theWord) =&gt;{
&nbsp; let copy = Object.assign(wordFactory(),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {word: theWord,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; language: 'Japanese',
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lookUpUrl: 'http://jisho.org/search/'})
&nbsp; return Object.setPrototypeOf(copy, wordFactory);
}
const englishWord = englishWordFactory('dog');
const japaneseWord = japaneseWordFactory('犬');

wordFactory.reportLanguage = function(){
&nbsp; return `The language is: ${this.language}`;
}
console.log(japaneseWord.reportLanguage());
console.log(englishWord.reportLanguage());
</pre>

<p>It's not strictly necessary to use a factory function for <code>word</code>, but this does avoid the extra step of creating a prototype (and probably an arbitrary one) for it. Although it might seem like a hassle to manually set the prototype inside of the specific language factory functions, the alternative of manually setting them for each instance of a word would be worse.</p>
</section>

<p>&nbsp;</p>
</section>

<section data-type="sect1" id="inheritance-and-architecture-dGsOhR">
<h1>Inheritance And Architecture</h1>

<p>So far, we've seen a few different patterns for copying data, ranging from the classiest (pseudo-) classical, to the factory function which happily ignores most of the ideas around prototypes, constructors, any other lines we'd need to draw from box to box in a UML diagram.</p>

<p>To recap, we know that we can make solitary objects using:</p>

<ul>
	<li>object literals</li>
	<li>classes (uses <code>new</code>)</li>
	<li>constructor functions (uses <code>new</code>)</li>
	<li>factory functions (just returns an object)</li>
	<li><code>Object.assign</code> and <code>Object.create</code></li>
	<li>libraries (like mori.js and immutable.js)</li>
</ul>

<p>Additionally, when preferable to objects, we can make more specific containers as we need them, such as:</p>

<ul>
	<li>Set</li>
	<li>Map</li>
	<li>Array</li>
	<li>String</li>
	<li>Function</li>
	<li>Other JavaScript Types</li>
</ul>

<p>It's already a lot of options, but in order to round out the discussion a bit, let's address architectural concerns a bit more deeply, centered around answering the following questions:</p>

<ul>
	<li>Why do some people hate classes?</li>
	<li>What about multiple inheritance?</li>
	<li>Which Interfaces do you want?</li>
</ul>

<section data-type="sect2" id="why-do-some-people-hate-classes-68s9IWhA">
<h2>Why Do Some People Hate Classes?</h2>

<p>The first argument that some people latch onto is that <code>new</code>, <code>this</code>, <code>super</code>, and anything having to do with <em>classical</em> OOP style is not only detracts from their preferred mechanism of sharing data and behavior between JavaScript objects (hurting the purity and making things confusing), but some of these criticisms are of Object-Oriented Programming itself. They argue that it encourages bad practices like tight-coupling of components, and encourages deep hierarchies and mutable state.</p>

<p>The <code>class</code> keyword is a hard blow to those who have been advocates for avoiding class-based OOP in JavaScript for a long time.</p>

<p>On the pro side of things, people have always struggled awkwardly to force JavaScript to behave this way. If it is what Crockford might call a "footgun," then at the very least, condoning and standardizing the "footwounds" will make problems easier to search and fix. There's some degree of herd immunity if we're all suffering from the same disease.</p>

<p>Also on the pro side, as features grow around classes, richer APIs become available for reflection and inspecting your code. For example, error messages can be more detailed by default.</p>

<p>Additionally, having a sanctioned standard for something makes it easier to learn once (adapting with the spec as necessary), rather than chasing the latest and greatest way to avoid a mostly benign "syntactic sugar" for constructor functions.</p>

<p>The criticisms of classical OOP itself should be taken very seriously however. A deeply nested hierarchy will be very hard to debug and maintain. Critics are not wrong to say that the <code>extends</code> keyword encourages a deep hierarchy (eg. class <code>Dog</code> extends <code>Pet</code> extends <code>Animal</code> extends <code>Organism</code>), but it does not necessarily demand it. They're also not wrong to feel that parent-child classes tend to be tightly coupled.</p>

<p>Another question critics of classes raise is "What About Multiple Inheritance?"</p>
</section>

<section data-type="sect2" id="what-about-multiple-inheritance-lKsmCphz">
<h2>What About Multiple Inheritance?</h2>

<p>When people discuss multiple inheritance, they mean a child class inheriting from multiple parents. If we had a clean solution for this in JavaScript, it would probably mean allowing for <code>extends</code> to take multiple base classes as parents.</p>

<p>Although this type of mechanism is supported in some languages, Python for example, it can create some confusion. If class A get all its properties from class B and C, how does it resolve conflicts when a property exists in both parents? It depends on the language.</p>

<p>If JavaScript had a class-based mechanism for multiple inheritance, it might look something like this:</p>

<pre data-type="programlisting">
class Barky{
&nbsp; bark(){ console.log('woof woof')}
}
class Bitey{
&nbsp; bark(){ console.log('grrr')},
&nbsp; bite(){ console.log('real bite')}
}
class Animal{
&nbsp; beFluffy(){ console.log('fluffy')},
&nbsp; bite(){ console.log('normal bite')}
}

// this is not possible:
class Dog extends (Animal, Barky, Bitey) { }
dog = new Dog;
dog.bite();
dog.beFluffy(); // this won't work
</pre>

<p>But it doesn't. <code>dog</code> will bite like a <code>Bitey</code> but has no idea how to be fluffy like an <code>Animal</code>. This isn't multiple inheritance. <code>Dog</code> extends <code>Bitey</code>. It's as simple as that. This is not a mechanism for multiple inheritance at all. Rather, <code>(Animal, Barky, Bitey)</code> just evaluates to <code>Bitey</code>. Check out the following:</p>

<pre data-type="programlisting">
//try this in console:
(1, 4, 3, 7);</pre>

<p>What do you expect this to evaluate to? Well, the answer is <code>7</code>. In some languages this expression would be an array or list literal. In others it would throw an error. In JavaScript, we get this questionable behavior of returning the last value inside the parens. This is what happened with our earlier attempt at multiple inheritance. This weird mechanism does NOT make class-based multiple inheritance possible. <code>Dog</code> extends <code>Bitey</code>, end of story.</p>

<p>JavaScript doesn't have a class-based way to do multiple inheritance. For that you need some other approach. Other languages would term this a "module," "interface," or "mix in."</p>

<p>What does that look like in JavaScript? Here's one option that we've seen earlier in the chapter:</p>

<pre data-type="programlisting">
const barky = {
&nbsp; bark(){ console.log('woof woof')}
}
const bitey = {
&nbsp; bark(){ console.log('grrr')}
&nbsp; bite(){ console.log('real bite')}
}
const animal = {
&nbsp; beFluffy(){ console.log('fluffy')}
&nbsp; bite(){ console.log('normal bite')}
}
const myPet = Object.assign(Object.create(animal), barky, bitey);</pre>

<p>This will give us access to all three functions (<code>bark</code>, <code>bite</code>, and <code>beFluffy</code>). But if we dig a little deeper, we'll see that this is not as simple as we might expect:</p>

<pre data-type="programlisting">
console.log(myPet);
{ bark: [Function: bark], bite: [Function: bite] }
console.log(Object.getPrototypeOf(myPet));
{ beFluffy: [Function: beFluffy], bite: [Function: bite] }
</pre>

<p>So our <code>myPet</code> object is actually relying on its prototype, the <code>animal</code>, for the <code>beFluffy</code> function. These are linked, so if we alter our <code>beFluffy</code> function on <code>animal</code>, it will update on <code>myPet</code> as well.</p>

<pre data-type="programlisting">
animal.beFluffy = function(){ console.log('not fluffy')}
myPet.beFluffy();
// prints "not fluffy"
</pre>

<p>We can even add new attributes to that <code>animal</code> to make changes to <code>myPet</code> on the fly:</p>

<pre data-type="programlisting">
animal.hasBankAccount = false;
console.log(myPet.hasBankAccount); // prints false
</pre>

<p>What if we try to augment the <code>bite</code> function?</p>

<pre data-type="programlisting">
bitey.bite = function(){
&nbsp; console.log("don't bite");
}
myPet.bite();
// prints "real bite"
</pre>

<p>There are two implications here. First, the function, <code>bite</code>, is attached directly to the <code>myPet</code> from <code>bitey</code>. Even though <code>myPet</code>'s prototype (<code>animal</code>) also has a <code>bite</code> function, it is overruled by the function directly attached to <code>myPet</code> that comes from <code>bitey</code>. Second, it is an actual copy. There is no linkage between <code>bitey</code> and <code>myPet</code>.</p>

<p>&nbsp;As far as our last function, <code>bark</code>, does <code>myPet</code> inherit this from <code>bitey</code> or <code>barky</code>?</p>

<p>Let's look again at how we created <code>myPet</code>:</p>

<pre data-type="programlisting">
const myPet = Object.assign(Object.create(animal), barky, bitey);
</pre>

<p>It turns out that, as parameters to <code>Object.assign</code>, the properties of objects to the right will be overrule those to the left.</p>

<pre data-type="programlisting">
myPet.bark();
// prints "grrr"
</pre>

<p><code>bitey</code>'s <code>bark</code> beats <code>barky</code>'s <code>bark</code> because <code>bitey</code> was last.</p>

<p>&nbsp;</p>

<aside data-type="sidebar" id="is-a-vs-is-just-a-PGH2iAClhb">
<h5>"is a" vs. "is <em>just</em> a"</h5>

<p>With simple, one parent inheritance, it is generally obvious that we are intending to say that something is a subtype of something else (eg. a <code>Person</code> is a subtype of <code>Organism</code>).</p>

<p>But what if a <code>Person</code> is also a subtype of <code>DatabaseRecord</code> or (shudder) <code>Resource</code>?</p>

<p>In those cases, our model of a person is not "just" an organism, so multiple inheritance makes more sense. We just attach relevant behaviors to them.</p>

<p>It isn't always easy to guess how a program will evolve, and inheritance hierarchies tend to be inflexible. If you want some inspiration for other ways to model object relationships, we'll cover "has a" later in this chapter, but you might also want to investigate Database Normalization, as well as ECS ("entity-component systems") which tends to be used heavily in game development.</p>
</aside>

<p>&nbsp;</p>
</section>

<section data-type="sect2" id="which-interfaces-do-you-want-rKsQuph6">
<h2>Which Interfaces do you want?</h2>

<p>There's more to the story here. Although we showed earlier that a factory function severs the prototypal link in the <code>Object.create</code> pattern, there is another option. Before we used this:</p>

<pre class="pre drop-element-attached-top drop-element-attached-center drop-target-attached-bottom drop-target-attached-center" data-type="programlisting">
const myPet = Object.assign(Object.create(animal), barky, bitey);
</pre>

<p>That creates a prototypal link between <code>myPet</code> and <code>animal</code>. This can be useful because we can add functionality to <code>animal</code> and have it inherited by <code>myPet</code> (as well as other objects that were created through a similar mechanism).</p>

<p>But if we want a new object with the existing behavior, but without the baggage of a prototype, we could do this instead:</p>

<pre data-type="programlisting">
const myPet = Object.assign({}, animal, barky, bitey);
</pre>

<p>Now <code>animal</code> acts just like <code>barky</code> and <code>bitey</code>. We can add properties to <em>them</em>, but <code>myPet</code> is unaffected:</p>

<pre data-type="programlisting">
animal.hasBankAccount = false;
console.log(myPet.hasBankAccount); // prints undefined
</pre>

<p>Another way to look at this, is that <code>myPet</code>'s prototype is now <code>{}</code>, rather than <code>animal</code>.</p>

<pre data-type="programlisting">
console.log(Object.getPrototypeOf(myPet));
// prints "{}"</pre>

<p>And also notice that <code>beFluffy</code> (the function inherited from <code>animal</code>), is defined directly on <code>myPet</code>:</p>

<pre data-type="programlisting">
console.log(myPet);

// prints 
{ beFluffy: [Function: beFluffy],
&nbsp; bite: [Function: bite],
&nbsp; bark: [Function: bark] }</pre>

<p>Most of the time, your primary concern will just be whether or not an object has a particular function or other property attached to it. In other words, "can I call this function with this object?" is a question that is absolutely fundamental in defining your API. As such, it is worth documenting, testing, manipulating, and refactoring.</p>

<p>But there is another broad and confusing set of interfaces underneath every JavaScript program. Do you want to use <code>Object.getPrototypeOf</code>? What about <code>Object.is</code>? <code>.__proto__</code>? <code>.prototype</code>? <code>.constructor</code>? <code>.keys</code>? <code>Reflect.ownKeys</code>? <code>Reflect.has</code>? <code>typeof</code>? <code>instanceof</code>?</p>

<p>Let's call this "JavaScript's deep dark underbelly."</p>

<p>Are you confident that these all behave as you expect? Are the desired properties enumerable when you want to loop through an object? When you create a new object, are you exposing either your new or old objects to side-effects?</p>

<p>You're likely to encounter projects that favor one style or another. You might even see a code base with a dual personality, perhaps with half of it in a classical style and the other half using factory functions. Whatever your preferred style is, rewriting the "wrong" style is likely to be painful, and possibly confusing and insulting to other team members.</p>

<p>Although it is best to promote confidence early in a project by having answering the question of "Which JavaScript Are You Using? (see Chapter 2)" with a style guide (and better yet, a linter that runs in your editor to enforce this automatically), you won't always be so lucky.</p>

<p>On a project that lacks opinions on a given style, and hurts confidence in that second interface (that of inspection and reflection), what should you do?</p>

<p>If you are not confident in a piece of code, write a test. For example, for this code:</p>

<pre data-type="programlisting">
const myPet = Object.assign({}, animal, barky, bitey);
</pre>

<p>Use "characterization tests" to develop confidence in things like <code>Object.keys(myPet)</code>, <code>myPet.__proto__</code>, <code>Object.getOwnPropertyNames(myPet)</code>, <code>Object.getPrototypeOf(myPet)</code>, and any other members of this deeper interface of JavaScript. As we practiced in Chapter 4, <code>wish(value, true)</code>, or <code>assert(value === null)</code>. Then use the output of that characterization test to fill in the test: <code>wish(value === valueFromOutput)</code> or <code>assert(value === valueFromOutput)</code></p>

<p>Aren't these values already tested within JavaScript browser implementations? Yes. Absolutely. They already have tests covering them. Are they "implementation details" which many advocate against writing tests for? Definitely. Will these tests be brittle if you change from classes to factory functions or from factory functions to classes? Yes.</p>

<p>But if it causes confusion in your code, should you test these functions in spite of that?</p>

<p>Without a doubt. It does not matter how much a piece of code is <em>external to your code base</em> or how much of an <em>implementation detail</em> it is. You can use tests to clear up your confusion (you won't be the only one on the team confused anyways) and have more confidence in your code. Additionally, you may be relying on "JavaScript's deep dark underbelly" more than you think. For instance, what seems like it should be a cosmetic change might be affect a property's enumerability or an object's prototype.</p>

<p>If letting your code break in tests instead of in production is your goal, creating characterization tests like these can add a layer of confidence that rigidly "only testing the 'public interface'" may not give you.</p>

<p>&nbsp;</p>
</section>

<p>&nbsp;</p>
</section>

<section data-type="sect1" id="has-a-relationships-D1sGIn">
<h1>Has-A Relationships</h1>

<p>So far in this chapter, we've been looking at multiple objects from the perspective of "is-a" (or "is a sub-type of") relationships. For simple inheritance, an <code>EnglishWord</code> is-a <code>Word</code>. Even when we dealt with mix-ins/multiple inheritance/modules, <code>myPet</code> is-a <code>animal</code>, but <code>myPet</code> is-a <code>bitey</code> and <code>myPet</code> is-a <code>barky</code> also.</p>

<p>We saw how these "is-a" relationships may <em>imply</em> a prototypal link between child and parent, but according to stylistic choices within JavaScript, that link may be severed despite any adopted similarities of interface between the objects. We also saw how establishing or severing that link can impact many interfaces within "JavaScript's deep dark underbelly."</p>

<p>What we haven't talked about is that <em>composing objects does not necessarily imply inheriting properties</em>.</p>

<p>Is a <code>HorseWithABriefCase</code> a sub-type of a <code>Horse</code>? That sounds awfully specific. Maybe it's a sub-type of <code>HorseWithObject</code>, or should it be a sub-type of <code>BusinessHorse</code>? We could put all of our horses onto a hierarchy in some form, but then we'll need an object (and/or class) that ends up describing every attribute, lest our <code>SickHorse</code> cannot get the antibiotics she needs because <code>DoctorHorseWithoutAnyMedicine</code> is perfectly unhelpful in that scenario.</p>

<p>Obviously, we already have a way to deal with this by storing properties (of arbitrary types) on objects. In chapters 6 and 7, we dealt with a <code>classifier</code> that <em>has-a</em> <code>songList</code>. In our <code>Object.create</code>/<code>Object.assign</code> mix-in based inheritance from earlier in the chapter, we were copying properties from one object to another. By contrast, in our <code>classifier</code>, we had to specifically "drill-down" into the <code>songList</code> via <code>classifier.songList.addSong</code> (until we wrote the delegate function to drill-down for us, allowing us to instead write <code>classifier.addSong</code>).</p>

<p>As for our horses, we could start by doing something like this:</p>

<pre data-type="programlisting">
const horse = {
  inventory: ["briefcase"],
  profession: "hippo jockey",
  healthy: true
}</pre>

<p>As our program grows in complexity, we might need a lot of horses, so we'd use a class, constructor function, <code>Object.create</code>, or a factory function to help us get more horses. If we needed to add behaviors to the horses, we would add functions as properties.</p>

<p>If <code>inventory</code> or <code>briefcase</code> or other properties needed to be more complicated, we'd spin them out as their own objects (as we did with <code>songList</code> in chapter 7). If they needed some behavior to be attached, we'd add functions to those objects.</p>

<p>The reason for glossing over a general approach for how to grow JavaScript objects without a hierarchy is that it is not usually how things go wrong in JavaScript programs. Although building a complex, deep, or complicated hierarchy of JavaScript classes/objects is possible and may become more of a widespread problem as OOP with classes becomes more popular, as of this writing, the worst JavaScript code-bases are much more likely to suffer from a <em>lack of structure</em> rather than <em>too much structure</em> of the wrong kind.</p>

<p>That said, next we'll address a few structural mistakes that you might see from time to time.</p>
</section>

<section data-type="sect1" id="inheritance-antipatterns-0KsqC8">
<h1>Inheritance Antipatterns</h1>

<p>Here we'll look at two issues that can come up when the wrong kind of structure is in place. Here are the antipatterns we'll address:</p>

<ul>
	<li>Hyperextension (Hierarchy is too deep)</li>
	<li>Goat and Cabbage Raised By a Wolf (Parent and children have nothing in common)</li>
</ul>

<p>In both cases, the motivation likely comes from a good place. Programmers don't like to just copy and paste code with minor variations. This is called "cargo cult" coding, and is a brand new programmer's best friend.</p>

<p>To avoid that, new aspects of a hierarchy are created instead of extracting functions and sub-objects that could be shared or held independently.</p>

<section data-type="sect2" id="hyperextension-4Rs0fKCR">
<h2>Hyperextension</h2>

<p>Here we have an example of a hierarchy that is too deep.</p>

<p><code>SpecificClientReport</code> inherits from <code>ClientReport</code> which inherits from <code>GenericReport</code> which inherits from <code>Report</code>.</p>

<pre data-type="programlisting">
class Report{
&nbsp; constructor(params){
&nbsp;&nbsp;&nbsp; this.params = params;
&nbsp; }
&nbsp; printReport(params){
&nbsp;&nbsp;&nbsp; return params;
&nbsp; }
}
class GenericReport extends Report{
&nbsp; constructor(params){
&nbsp;&nbsp;&nbsp; super(params);
&nbsp;&nbsp;&nbsp; this.params = params;

&nbsp; }
&nbsp; printReport(params){
&nbsp;&nbsp;&nbsp; return super.printReport(Object.assign(this.params, params));
&nbsp; }

}
class ClientReport extends GenericReport{
&nbsp; constructor(params){
&nbsp;&nbsp;&nbsp; super(params);
&nbsp;&nbsp;&nbsp; this.params = params;

&nbsp; }
&nbsp; printReport(params){
&nbsp;&nbsp;&nbsp; return super.printReport(Object.assign(this.params, params));
&nbsp; }

}
class SpecificClientReport extends ClientReport{
&nbsp; constructor(params){
&nbsp;&nbsp;&nbsp; super(params);
&nbsp;&nbsp;&nbsp; this.params = params;
&nbsp; }
&nbsp; printReport(params){
&nbsp;&nbsp;&nbsp; return super.printReport(Object.assign(this.params, params));
&nbsp; }

}
report = new SpecificClientReport({whatever: 'we want', to: 'add'});
console.log(report.printReport({extra: 'params'}));
</pre>

<p>If there is ever a good reason not to just pass the word "params," "object," or "options" around, here it is. Imagine this code, but with more functions, and alterations of <code>params</code> <em>and</em> <code>this.params</code> all along the way.</p>

<p>If we had function calls to other members of this hierarchy, we would address them too, but here we'll just to focus on <code>SpecificClientReport</code>. First, we need a test instead of a logging statement. Create a characterization test by adding these lines to the bottom:</p>

<pre data-type="programlisting">
const wish = require('wish');
const deepEqual = require('deep-equal');
wish(report.printReport({extra: 'params'}), true);
</pre>

<p>We run it and we get an error:</p>

<pre data-type="programlisting">
WishCharacterization: report.printReport({extra: 'params'})
  evaluated to {"whatever":"we want","to":"add","extra":"params"}
</pre>

<p>That object is exactly what we need to replace our characterization test:</p>

<pre data-type="programlisting">
wish(deepEqual(report.printReport({extra: 'params'}),
&nbsp;&nbsp;&nbsp;&nbsp; {whatever:"we want", to:"add", extra:"params"}))
</pre>

<p>And our test passes. Now we can safely refactor.</p>

<p>There are two approaches we could take. First, we could assume that there's nothing special about our <code>SpecificClientReport</code> and try this instead:</p>

<pre data-type="programlisting">
report = new Report({whatever: 'we want', to: 'add'});
wish(deepEqual(report.printReport({extra: 'params'}),
&nbsp;&nbsp;&nbsp;&nbsp; {whatever:"we want", to:"add", extra:"params"}));
</pre>

<p>Note that we're just changing the report variable here (and in the next snippet). The test is the same. We get an error, so we could try moving down one level:</p>

<pre data-type="programlisting">
report = new GenericReport({whatever: 'we want', to: 'add'});
wish(deepEqual(report.printReport({extra: 'params'}),
&nbsp;&nbsp;&nbsp;&nbsp; {whatever:"we want", to:"add", extra:"params"}))
</pre>

<p>This works fine. That means (assuming there are no other places using them) we could delete&nbsp;<code>SpecificClientReport</code> and <code>ClientReport</code>. If they both have other places using them, we should see if we could move those places up in the hierarchy to try to prune any leaves we can.</p>

<p>The second way to handle this is to see if we can inline the superclass's functionality. Because <code>SpecificClientReport</code> and <code>GenericReport</code> behave the same way (according to our tests), it's fine to start where we just left off. If the last approach was difficult for your code base, you might start with this technique instead (before climbing the superclasses).</p>

<p>Anyways, we're left with this:</p>

<pre data-type="programlisting">
class Report{
&nbsp; constructor(params){
&nbsp;&nbsp;&nbsp; this.params = params;
&nbsp; }
&nbsp; printReport(params){
&nbsp;&nbsp;&nbsp; return params;
&nbsp; }
}
class GenericReport extends Report{
&nbsp; constructor(params){
&nbsp;&nbsp;&nbsp; super(params);
&nbsp;&nbsp;&nbsp; this.params = params;

&nbsp; }
&nbsp; printReport(params){
&nbsp;&nbsp;&nbsp; return super.printReport(Object.assign(this.params, params));
&nbsp; }

}
const wish = require('wish');
const deepEqual = require('deep-equal');
report = new GenericReport({whatever: 'we want', to: 'add'});
wish(deepEqual(report.printReport({extra: 'params'}),
&nbsp;&nbsp;&nbsp;&nbsp; {whatever:"we want", to:"add", extra:"params"}));
</pre>

<p>To get a little clarity, we can start with removing the <code>constructor</code> function from <code>GenericReport</code> (assuming this we are the only consumer), as it is redundant with what happens in <code>super</code>. As far as the <code>printReport</code> function, all super does is return what it is given (the <code>params</code>, not the <code>this.params</code>). That means we don't have to call super at all, making our new GenericReport look like this:</p>

<pre data-type="programlisting">
class GenericReport extends Report{
&nbsp; printReport(params){
&nbsp;&nbsp;&nbsp; return Object.assign(this.params, params);
&nbsp; }
}
</pre>

<p>The test passes. We're almost ready to free this child class. However, if we remove <code>extends Report</code> now, we'll get an error, because <code>this.params</code> was never assigned. That means we need our constructor back first. After that, we're free to remove the link to the parent.</p>

<pre data-type="programlisting">
class GenericReport{
&nbsp; constructor(params){
&nbsp;&nbsp;&nbsp; this.params = params;
&nbsp; }
&nbsp; printReport(params){
&nbsp;&nbsp;&nbsp; return Object.assign(this.params, params);
&nbsp; }
}
</pre>

<p>And everything works. If <code>GenericReport</code> was the only thing using <code>Report</code>, we could remove it (<code>Report</code>) now. After that, the ugliest things in here are the non-specific names: <code>params</code> should be something more specific (see Chapter 6), and <code>GenericReport</code> could possibly be called <code>Report</code> now.</p>

<p>If you decide to prune a hierarchy like this, it is crucial to have version control and tests in place that can check all of the consumers (object makers/function callers) of the classes along the hierarchy.</p>

<p>It's unlikely to go as smoothly as this. Ultimately, the goal is to carve off independent leaves and extract shared functions when you can. Don't try to "refactor" a complex hierarchy like this (but with many more side-effects, attributes, and functions) all at once, especially not without tests in place.</p>
</section>

<section data-type="sect2" id="goat-and-cabbage-raised-by-a-wolf-68sbcYCA">
<h2>Goat and Cabbage Raised By a Wolf</h2>

<p>In this case, the children look nothing like the parent or each other. All the parent does is cause confusion and add a layer of indirection.</p>

<pre data-type="programlisting">
class Agent{
&nbsp; constructor(name, type){
&nbsp;&nbsp;&nbsp; this.name = 'name';
&nbsp;&nbsp;&nbsp; if(Math.random() &gt; .5){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.type = 'user';
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.type = 'project';
&nbsp;&nbsp;&nbsp; }
&nbsp; }
&nbsp; static makeProjectOrUser(agent){
&nbsp;&nbsp;&nbsp; if(agent.type === 'user'){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Object.assign(Object.create(new User), agent);
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return Object.assign(Object.create(new Project), agent);
&nbsp;&nbsp;&nbsp; }
&nbsp; }
}

class User extends Agent{
&nbsp; sayName(){
&nbsp;&nbsp;&nbsp; return `my name is ${this.name}`;
&nbsp; }

}

class Project extends Agent{
&nbsp; sayTheName(){
&nbsp;&nbsp;&nbsp; return `the project name is ${this.name}`;
&nbsp; }
}

const agent = new Agent('name');
const projectOrUser = Agent.makeProjectOrUser(agent);
if(projectOrUser.type === 'user'){
&nbsp; console.log(projectOrUser.sayName());
}else{
&nbsp; console.log(projectOrUser.sayTheName());
}
</pre>

<p>On this code, imagine that this is basically as common as it gets between the two objects, and there are thousands of lines backing up the difference in them (all requiring tests and type checking).</p>

<p>First, we need to get some characterization tests in place. Add these lines to the end:</p>

<pre data-type="programlisting">
const wish = require('wish');
if(projectOrUser.type === 'user'){
&nbsp; wish(projectOrUser.sayName(), true);
}else{
&nbsp; wish(projectOrUser.sayTheName(), true)
}
</pre>

<p>We'll have a 50/50 chance of getting one of these:</p>

<pre data-type="programlisting">
WishCharacterization: projectOrUser.sayName() evaluated to 
  "my name is name"

// and

WishCharacterization: projectOrUser.sayTheName() evaluated to 
  "the project name is name"
</pre>

<p>Now we can just replace our characterization tests with these:</p>

<pre data-type="programlisting">
if(projectOrUser.type === 'user'){
&nbsp; wish(projectOrUser.sayName() ===
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "my name is name");
}else{
&nbsp; wish(projectOrUser.sayTheName() ===
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "the project name is name")
}
</pre>

<p>We will always have problems as long as the following two lines are in place:</p>

<pre data-type="programlisting">
const agent = new Agent('name');
const projectOrUser = Agent.makeProjectOrUser(agent);
</pre>

<p>Right now, these create a <code>project</code> or a <code>user</code>, based on a coin toss in the constructor. Since that is where everything stems from, let's move the <code>coinToss</code> into a function:</p>

<pre data-type="programlisting">
function coinToss(){
&nbsp; return Math.random() &gt; .5;
}

class Agent{
&nbsp; constructor(name, type){
&nbsp;&nbsp;&nbsp; this.name = name;
&nbsp;&nbsp;&nbsp; if(coinToss()){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.type = 'user';
&nbsp;&nbsp;&nbsp; }else{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; this.type = 'project';
&nbsp;&nbsp;&nbsp; }
&nbsp; }
...
}
</pre>

<p>Next, because <code>coinToss</code> is always called, we can move that to our calling code, outside the constructor:</p>

<pre data-type="programlisting">
class Agent{
&nbsp; constructor(name, type){
&nbsp;&nbsp;&nbsp; this.name = name;
&nbsp;&nbsp;&nbsp; this.type = type;
&nbsp; }
}
</pre>

<p>And move our <code>coinToss</code> to be used before our <code>agent</code> is given an identity:</p>

<pre data-type="programlisting">
let agent;
if(coinToss()){
&nbsp; agent = new Agent('name', 'user');
}else{
&nbsp; agent = new Agent('name', 'project');
}
// replaces
// const agent = new Agent('name');
</pre>

<p>Now, we want to "push down" the constructor into the sub-types:</p>

<pre data-type="programlisting">
class User extends Agent{
&nbsp; constructor(name, type){
&nbsp;&nbsp;&nbsp; super()
&nbsp;&nbsp;&nbsp; this.name = name;
&nbsp;&nbsp;&nbsp; this.type = type;
&nbsp; }
&nbsp; sayName(){
&nbsp;&nbsp;&nbsp; return `my name is ${this.name}`;
&nbsp; }
}

class Project extends Agent{
&nbsp; constructor(name, type){
&nbsp;&nbsp;&nbsp; super()
&nbsp;&nbsp;&nbsp; this.name = name;
&nbsp;&nbsp;&nbsp; this.type = type;
&nbsp; }
&nbsp; sayTheName(){
&nbsp;&nbsp;&nbsp; return `the project name is ${this.name}`;
&nbsp; }
}
</pre>

<p>Annoyingly, as long as we're extending <code>Agent</code>, in JavaScript, we must call its constructor (with <code>super</code>) in order to access this and assign properties in our subtypes. Note that we don't care about passing arguments to <code>super</code> because we're assigning the properties we need anyways.</p>

<p>Ok. Here's the exciting part. Now we can call those constructors directly:</p>

<pre data-type="programlisting">
let agent;
if(coinToss()){
&nbsp; agent = new User('name', 'user');
}else{
&nbsp; agent = new Project('name', 'project');
}
</pre>

<p>Now we can delete a lot of code, leaving us with just the following:</p>

<pre data-type="programlisting">
function coinToss(){
&nbsp; return Math.random() &gt; .5;
}

class User{
&nbsp; constructor(name, type){
&nbsp;&nbsp;&nbsp; this.name = name;
&nbsp;&nbsp;&nbsp; this.type = type;
&nbsp; }
&nbsp; sayName(){
&nbsp;&nbsp;&nbsp; return `my name is ${this.name}`;
&nbsp; }
}

class Project{
&nbsp; constructor(name, type){
&nbsp;&nbsp;&nbsp; this.name = name;
&nbsp;&nbsp;&nbsp; this.type = type;
&nbsp; }
&nbsp; sayTheName(){
&nbsp;&nbsp;&nbsp; return `the project name is ${this.name}`;
&nbsp; }
}

let agent;
if(coinToss()){
&nbsp; agent = new User('name', 'user');
}else{
&nbsp; agent = new Project('name', 'project');
}

const wish = require("wish");
if(agent.type === 'user'){
&nbsp; wish(agent.sayName() ===
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "my name is name");
}else{
&nbsp; wish(agent.sayTheName() ===
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "the project name is name")
}
</pre>

<p>No more <code>super</code>. No more <code>extends</code>. Now you're free to rename the variable <code>agent</code> to anything you like. You might notice another potential refactoring in unifying the interface of the function <code>sayName</code> and <code>sayTheName</code>. By all means, go ahead, as long as it won't tempt you to subclass these again.</p>

<p>If you think the <code>coinToss</code> to decide on a type of object is a bit far-fetched, you're totally correct. The point is, however, that ambivalent constructors that could be based on date, time, or any other dynamic situation <em>could</em> lead to this kind of situation. Or it could be the result of one ambiguous object creation slowly spreading throughout. I've seen it happen.</p>

<p>The lesson here is that if you have two classes that share some state or behavior, subclassing may not be a great way to remove duplication, and it could lead your team down a path of lots and lots of type checking. Sometimes, you just need a type attribute (we'll look at a way to avoid a conditional check with these in Chapter 9). Other times, the duplication might be able to be extracted into functions or another object. In any case, refactoring duplication is very easy and safe as compared to dismantling a "goat and cabbage raised by a wolf" inheritance issue.</p>
</section>
</section>

<section data-type="sect1" id="wrapping-up-mnsKum">
<h1>Wrapping Up</h1>

<p>In this chapter, we looked at a few ways to build up as well as break down a hierarchy. It's worth noting that for some people, OOP is more trouble than it's worth. If you're one of those people, you'll probably like learning about Functional Programming in Chapter 11. If you like OOP, the next chapter will give you a few more tools (patterns) to apply to your work.</p>

<p>Whatever your stance on OOP, you're likely to see code that could benefit from the kind of organization that OOP provides. On the other hand, you might find that misapplied OOP itself is the cause of complexity in some code bases. In any case, none of this suggests that objects or classes are inherently bad to use.</p>
</section>
</section>

  </body>
</html>
