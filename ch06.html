<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Refactoring JavaScript</title>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"> </script>
    <link rel="stylesheet" type="text/css" href="theme/html/html.css">
  </head>
  <body data-type="book">
    <section data-type="chapter" id="refactoring-simple-structures-28wsV">
<h1>Refactoring Simple Structures</h1>

<p>Over the next two chapters, we will be dealing with code that is messy, undertested, and does something cool. Note that both of these chapters work from the same project codebase.</p>

<p>The first part that is cool is that if you have interest, but lack experience, in machine learning, we're using a particular algorithm is fairly simple and still very powerful. It's called a Naive Bayes Classifier (NBC). You can use it to "classify" things based previous knowledge. A spam filter is a frequently cited example. An NBC has two basic steps. First, you give it data that you already know how a human would classify it (eg. "These 35 subject lines are from spam emails."). That is called "training" the algorithm. Then, you give it a new piece of data and ask it what category it likely fits into (eg. "Here is the subject line of an email we just received. Is it spam or not?").</p>

<p>The second cool thing (if you're into playing music at all) is that our specific application of the algorithm will use chords in songs along with their difficulty as training data. Following that, we can feed it the chords of other songs, and it will automatically characterize its difficulty for us. At the end of these two chapters, we'll make some tweaks to have the algorithm guess at whether a segment of text is understandable or not (with the assumption that we understand English, but not Japanese).</p>

<div data-type="note" id="but-i-dont-know-anything-about-music-QKtyIj"><h6>Note</h6>
<h1>But I don't know anything about music!</h1>

<p>That's ok. This won't be technical as far as music goes. All you need to know is that to play songs (on guitar for example), you usually need to know some "chords," which are a bunch of notes put together.</p>

<p>If you plucked a guitar string or hit a piano key, you'd be playing a "note." And if you strum multiple strings or hit multiple piano keys (playing multiple "notes" at once), you'd be playing a "chord." Some chords are harder to play than others.</p>

<p>Music can be complicated, but for our purposes, songs are simply made up of chords, and how difficult the chords are to play determines how difficult it is to play the song overall.</p>
</div>

<p>This might seem like an intimidating or complex problem, but two things will keep us afloat. First, the basis of the entire program is just multiplying and comparing different sets of numbers. Second, we can rely on our abilities to test and refactor to get us through, even if some details don't intuitively make sense at first.</p>

<p>There are a few things we won't be covering to a great deal. Linters (discussed in Chapter 3) like JSHint and JSCS (now ESLint) checker criteria (of which there are hundreds) will not all be specifically addressed. However, it is recommended that you try these tools out in your editor. More specifically, we won't be covering single quotes vs. double quotes, ASI (automatic semicolon insertion) and "unnecessary" semicolons, or the amount of spaces between braces and the object values that live inside of them.</p>

<p>Those details are nice to have consistency on, so by all means, use a linter as a "living style guide," but covering all the tiny things that they catch here, some of which are fairly opinionated (eg. <code>x===3</code> should have spaces and instead be <code>x === 3</code>) would neither be interesting or useful to someone using modern tools and already using some determined form of JavaScript (see Chapter 2) that they want to write.</p>

<aside data-type="sidebar" id="why-not-just-cars-bank-accounts-and-employees-MqHgSe">
<h5>Why not just Cars, Bank Accounts, and Employees?</h5>

<p>We aren't talking about cars, employees or bank accounts? Not only are those examples as overused as the quote from Spiderman's Uncle Ben in tech books, but also consider this passage from <em>Gradus Ad Parnassum</em>.</p>

<blockquote>
<p>Perhaps the hope of future riches and possessions induces you to choose this life? If this is the case, believe me you must change your mind; not Plutus but Apollo rules Parnassus. Whoever wants riches must take another path.</p>
</blockquote>

<p>Aloys is talking about music theory, and not programming. Nonetheless, economic acquisitions forming the basis of craft and knowledge (unless that craft and knowledge is economics I guess) just feels wrong.</p>

<p>You can use an NBC to help you learn a new language, study and instrument, or figure out how best to entertain yourself through media. Let Plutus have your 9 to 5 if he must, but we're all about the Apollo here.</p>
</aside>

<div data-type="note" id="dont-forget-the-advice-from-the-last-chapter-Nbtmty"><h6>Note</h6>
<h1>Don't forget the advice from the last chapter</h1>

<ul>
	<li>Try to keep bulk (complexity and lines of code) low&nbsp;</li>
	<li>Prefer explicit inputs to implicit inputs (although we're working in OOP style, so we're favoring implicit inputs in this chapter. See Chapter 11 for this code in FP style)</li>
	<li>Prefer implicit inputs to non-local inputs (free variables)</li>
	<li>Prefer real, meaningful return values to side-effects</li>
	<li>Keep side-effects to a minimum</li>
	<li>Have a well-defined <code>this</code> when possible for functions and other variables (attributes) by making them part of classes (or at least objects) to cut down on non-local inputs and global variables</li>
	<li>In JavaScript, mechanisms for privacy necessarily impact access, which can complicate code, especially when it comes to testing</li>
</ul>
</div>

<section data-type="sect1" id="the-code-dVsGhV">
<h1>The Code</h1>

<p>Here's the NBC, the initial "bad version" that we're going to improve upon throughout the next two chapters:</p>

<pre data-type="programlisting">
fs = require('fs');
// songs
imagine = ['c', 'cmaj7', 'f', 'am', 'dm', 'g', 'e7'];
somewhere_over_the_rainbow = ['c', 'em', 'f', 'g', 'am'];
tooManyCooks = ['c', 'g', 'f'];
iWillFollowYouIntoTheDark = ['f', 'dm', 'bb', 'c', 'a', 'bbm'];
babyOneMoreTime = ['cm', 'g', 'bb', 'eb', 'fm', 'ab'];
creep = ['g', 'gsus4', 'b', 'bsus4', 'c', 'cmsus4', 'cm6'];
army = ['ab', 'ebm7', 'dbadd9', 'fm7', 'bbm', 'abmaj7', 'ebm'];
paperBag = ['bm7', 'e', 'c', 'g', 'b7', 'f', 'em', 'a', 'cmaj7',
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'em7', 'a7', 'f7', 'b'];
toxic = ['cm', 'eb', 'g', 'cdim', 'eb7', 'd7', 'db7', 'ab', 'gmaj7',
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'g7'];
bulletproof = ['d#m', 'g#', 'b', 'f#', 'g#m', 'c#'];
song_11 = [];

var songs = [];
var labels = [];
var allChords = [];
var labelCounts = [];
var labelProbabilities = [];
var chordCountsInLabels = {};
var probabilityOfChordsInLabels = {};

function train(chords, label){
&nbsp; songs.push([label, chords]);
&nbsp; labels.push(label);
&nbsp; for (var i = 0; i &lt; chords.length; i++){
&nbsp;&nbsp;&nbsp; if(!allChords.includes(chords[i])){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allChords.push(chords[i]);
&nbsp;&nbsp;&nbsp; }
&nbsp; }
&nbsp; if(!!(Object.keys(labelCounts).includes(label))){
&nbsp;&nbsp;&nbsp; labelCounts[label] = labelCounts[label] + 1;
&nbsp; } else {
&nbsp;&nbsp;&nbsp; labelCounts[label] = 1;
&nbsp; }
};

function getNumberOfSongs(){
&nbsp;&nbsp; return songs.length;
};

function setLabelProbabilities(){
&nbsp; Object.keys(labelCounts).forEach(function(label){
&nbsp;&nbsp;&nbsp; var numberOfSongs = getNumberOfSongs();
&nbsp;&nbsp;&nbsp; labelProbabilities[label] = labelCounts[label] / numberOfSongs;
&nbsp; });
};

function setChordCountsInLabels(){
&nbsp; songs.forEach(function(i){
&nbsp;&nbsp;&nbsp; if(chordCountsInLabels[i[0]] === undefined){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chordCountsInLabels[i[0]] = {};
&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; i[1].forEach(function(j){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(chordCountsInLabels[i[0]][j] &gt; 0){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chordCountsInLabels[i[0]][j] =
chordCountsInLabels[i[0]][j] + 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; chordCountsInLabels[i[0]][j] = 1;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; });
&nbsp; });
}

function setProbabilityOfChordsInLabels(){
&nbsp; probabilityOfChordsInLabels = chordCountsInLabels;
&nbsp; Object.keys(probabilityOfChordsInLabels).forEach(function(i){
&nbsp;&nbsp;&nbsp; Object.keys(probabilityOfChordsInLabels[i]).forEach(function(j){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; probabilityOfChordsInLabels[i][j] =
probabilityOfChordsInLabels[i][j] * 1.0 / songs.length;
&nbsp;&nbsp;&nbsp; });
&nbsp; });
}

train(imagine, 'easy');
train(somewhere_over_the_rainbow, 'easy');
train(tooManyCooks, 'easy');
train(iWillFollowYouIntoTheDark, 'medium');
train(babyOneMoreTime, 'medium');
train(creep, 'medium');
train(paperBag, 'hard');
train(toxic, 'hard');
train(bulletproof, 'hard');

setLabelProbabilities();
setChordCountsInLabels();
setProbabilityOfChordsInLabels();



function classify(chords){
&nbsp; var ttal = labelProbabilities;
&nbsp; console.log(ttal);
&nbsp; var classified = {};
&nbsp; Object.keys(ttal).forEach(function(obj){
&nbsp;&nbsp;&nbsp; var first = labelProbabilities[obj] + 1.01;
&nbsp;&nbsp;&nbsp; chords.forEach(function(chord){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var probabilityOfChordInLabel =
probabilityOfChordsInLabels[obj][chord];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(probabilityOfChordInLabel === undefined){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; first + 1.01;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; first = first * (probabilityOfChordInLabel + 1.01);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; });
&nbsp;&nbsp;&nbsp; classified[obj] = first;
&nbsp; });
&nbsp; console.log(classified);
};

classify(['d', 'g', 'e', 'dm']);
classify(['f#m7', 'a', 'dadd9', 'dmaj7', 'bm', 'bm7', 'd', 'f#m']);
</pre>

<p>What does it do?</p>

<p>Honestly, what we have here is a little over 100 lines of fairly incomprehensible stuff. Although we could try to break it down, or look to the mathematical model of NBCs first, that is not our approach here.</p>

<p>We will be developing confidence in this code through testing and refactoring.</p>

<p>In general, we want to get code into a file (and also isolated in a <em>js</em> file if it was started as part of <code>&lt;script&gt;</code> tag inside an <em>html</em> file), then under version control, and then decide on a testing strategy.</p>

<div data-type="note" id="line-length-OXtXckha"><h6>Note</h6>
<h1>Line Length</h1>

<p>To ensure that everything in this chapter fits on the page, some lines have been aggressively been split onto two in a seemingly unnatural way:</p>

<pre data-type="programlisting">
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var probabilityOfChordInLabel =
probabilityOfChordsInLabels[obj][chord];</pre>

<p>For many situations, there are better places than the first column to continue a line. In the case of assignments, in such a limited space, we'll tend to continue in this way when we have to. Normally, you would hit a maximum desirable line length with a long array, string, or other data.</p>
</div>

<p>For these this and the following chapter, we will assume that you have a file called <code>nb.js</code> with the code listed above.</p>
</section>

<section data-type="sect1" id="our-strategy-for-confidence-MRsKse">
<h1>Our Strategy for Confidence</h1>

<p>Assuming you're all set up with the code from earlier, and have it saved to a file called <code>nb.js</code> that is under version control, let's get started.</p>

<p>Back to our model of what types of tests to write when (the diagram in Chapter 4), we know that we need characterization tests for untested code. But looking at our file, we discover with horror that none of our functions return anything: We have a bit of structure, but our functions just group lines of statements together and generate side-effects. Inputs come in the form of variables defined at the top-level scope, and variable reassignments run rampant.</p>

<p>Yikes. So what's our first course of attack? Run the file with node (<strong><code>node nb.js</code></strong>), and we should see the following output:</p>

<pre data-type="programlisting">
(from command line)
&gt;node nb.js
[ easy: 0.3333333333333333,
&nbsp; medium: 0.3333333333333333,
&nbsp; hard: 0.3333333333333333 ]
{ easy: 2.023094827160494,
&nbsp; medium: 1.855758613168724,
&nbsp; hard: 1.855758613168724 }
[ easy: 0.3333333333333333,
&nbsp; medium: 0.3333333333333333,
&nbsp; hard: 0.3333333333333333 ]
{ easy: 1.3433333333333333,
&nbsp; medium: 1.5060259259259259,
&nbsp; hard: 1.6884223991769547 }</pre>

<div data-type="note" id="did-you-get-an-error-Eptwu0sr"><h6>Note</h6>
<h1>Did you get an error?</h1>

<p>Specifically this one?</p>

<pre data-type="programlisting">
TypeError: allChords.includes is not a function</pre>

<p>If so, you probably have an old node version. Go to <a href="https://nodejs.org/">nodejs.org</a> and get version 6.7.0.</p>
</div>

<p>So print statements are our only output, which is not great. The good news is that we have running code, and it actually outputs something. That means that we actually have a test in place. Unfortunately, it is a manual one, but it doesn't require much setup (we don't need a test library to run <strong><code>node nb.js</code></strong> and see output). If we define our "public interface" to be the whole program, run as it is with no further options, we could be satisfied that this is the only test we may ever need.</p>

<p>Long term, this is not a great approach, and we bring in formal testing in the next chapter. For this chapter, we'll limp along with checking the output through our logging statements.</p>

<aside data-type="sidebar" id="these-results-stop-one-step-before-actual-classification-GqHrS0sz">
<h5>These Results Stop One Step Before Actual "Classification"</h5>

<p>In these results, we can see that we get numbers for each type of value (<code>easy</code>, <code>medium</code>, and <code>hard</code>). Where they are all the same (<code>0.333...</code>), what is printed is the base likelihood of classifying as that value simply based on the ratio of other samples falling into that value, or "category," if that's an easier way to think about it.</p>

<p>As for the ones with different values, whatever is the highest number in the set of values (<code>easy</code>, <code>medium</code>, or <code>hard</code>) reflects the classified data as belonging most strongly with that value. In other words, this means it's likely hard:</p>

<pre data-type="programlisting">
{ easy: 1.3433333333333333,
&nbsp; medium: 1.5060259259259259,
&nbsp; hard: 1.6884223991769547 }</pre>

<p>If used for a spam filter this message being classified would most likely be spam:</p>

<pre data-type="programlisting">
{ nonSpam: 3,
&nbsp; spam: 8 }</pre>

<p>It's trivial to pull out the highest number and report report the matching key, but that is the final step of this algorithm. If you want to write that code, and tests to go with it, feel free. We avoid it in this chapter because the numbers are more explicit, giving us more certainty that we haven't changed our algorithm.</p>
</aside>
&nbsp;

<p>Back to the question of confidence (through the result of our manual test), we need one more step: run it again (maybe 2 times or 5 times). And the result is still the same. That's great. Our algorithm is <em>deterministic</em>. A word of warning here is that before making this assumption, you should check the code for <code>Math.random</code>, <code>new Date</code>, and other sources of variation (including calls to remote urls) in the program before assuming it will always behave the same way.</p>

<p>So, now that we're reasonably confident in the behavior, how should we start refactoring this?</p>

<p>For this code, we are taking a broad view of refactoring. In practice, you might find another order more logical than what is presented here. In particular, after getting tests in place, it is often easiest to extract functions before doing anything else.</p>

<p>Extracting functions is often the best way to reveal the structure of a program, and is probably the most underutilized of refactoring techniques. However, we will wait until the next chapter to introduce it.</p>

<p>We delay extracting functions for three reasons:</p>

<ul>
	<li>These two chapters are roughly arranged from simple to complex techniques, and it's good to understand the simple ones first.</li>
	<li>Extracting functions often obviates other approaches. If we covered it first, some simpler (but still important) methods would become unnecessary.</li>
	<li>Additionally, when extracting functions, you often discover something else that could be done at the same time: for example, renaming a variable. To keep techniques isolated, we need to move in small steps first.</li>
</ul>

<p>Generally speaking, the techniques presented in this chapter are low-level. In other words, they are concerned with small pieces of code. They are more likely to be things that a linter could find or a text editor could "automatically refactor."</p>
</section>

<section data-type="sect1" id="renaming-things-6osMFD">
<h1>Renaming Things</h1>

<p>The easiest refactorings to do are simply renaming things that don't make sense: whether it's variables, functions, objects, or modules, this is a good place to start. In the worst case these break the program, and we <strong><code>git checkout .</code></strong> to get back to our previous good version.</p>

<p>On our hunt for bad names, we have a few things to look for:</p>

<ul>
	<li>misspelled words</li>
	<li>short names (abbreviations and one-letter names)</li>
	<li>non-descriptive/general names</li>
	<li>numbers in variable names</li>
	<li>doubled up names</li>
	<li>not CapitalCase for constructors</li>
	<li>not camelCase for functions and variables</li>
</ul>

<p>And consider that these may all apply to the following:</p>

<ul>
	<li>Variables</li>
	<li>Loop variables</li>
	<li>Functions</li>
	<li>Objects</li>
	<li>Classes</li>
	<li>Parameters</li>
	<li>Files</li>
	<li>Directories</li>
	<li>Modules</li>
	<li>Projects</li>
</ul>

<p>Does anything look obviously misspelled? Does not seem so, but the short name <code>ttal</code> stands out as not a real word. It could be a misspelling, or an intentional, but misguided abbreviation for <code>total</code>. For now, do a search and replace that turns <code>ttal</code> into <code>total</code>.</p>

<p>Run the program (our test). Same output? Great. Save and <strong><code>git commit -am '<em>fixed bad variable name</em>'</code></strong> and let's move on.</p>

<p>We have a variable name with a number and bucking the camel convention: <code>song_11</code>, which is just an empty array. To avoid numbers and snake case (using underscores), we could call this <code>songEleven</code>, but <code>blankSong</code> seems more fitting and specific. Save, run the file, and (assuming everything looks good), commit the changes.</p>

<p>Next, we have a variable name that is following the snake_convention, rather than the camelConvention: <code>somewhere_over_the_rainbow</code>. The fix is the same, search/replace/save/verify/commit. Make sure you find both instances of it.</p>

<p>Next is a tougher case, but using single letter variable names doesn't make sense for most JavaScript source code (although these are normal in compiled js, as build processes may shorten labels). <code>i</code> and <code>j</code> appear throughout the program, with their one variable name signaling that they are just an index, not requiring a full and descriptive name. This is nonsense. But why?</p>

<p>First, because these names are more resistant to change. If you apply the same workflow as we have been using to rename variables to single letter variable names, you are very likely to break something. Find/Replace should not have to require much focus, so when you want "only <code>i</code> if it's: <em>not</em> part of a bigger word/starts with var/has parens around it, etc", you will quickly find yourself in a more manual search and replace process than you want. This is complicated further when you have to search across files. Although a lot of editors let you search by regex, it's an extra step, and regex won't solve everything if the variable names are reused in various places.</p>

<p>Second, although these variables happen to be in the expected scopes, having variables that are not unique creates risk of them overwriting each other. What makes this worse is that this might be expected or relied upon behavior, so we don't know ahead of time that by changing one of these variable names, we aren't introducing a bug.&nbsp;</p>

<p>The third and worst thing about them is that they give no information about what is inside. It is somewhat conventional (a bad one as described above) to use <code>i</code> and <code>j</code> as indices inside of loops. In those cases, the names <code>index</code> and <code>innerIndex</code> are more appropriate when the variables represent <em>numerical</em> keys. Change <code>i</code> to <code>index</code> in the <code>train</code> function (there should be 5 of them). Save, check, commit.</p>

<aside data-type="sidebar" id="alternative-opinion-descriptive-variable-names-indicate-bad-code-0gHZHQFn">
<h5>Alternative Opinion: Descriptive Variable Names Indicate Bad Code</h5>

<p>This is a nuanced view, and doesn't apply to an easily attainable style in JavaScript, but in some languages (including some that compile to JavaScript), it is possible to specify much about a program through its "type system." In those cases, descriptive variable names may actually detract from the clarity of the possibilities provided by the "type signatures" of functions.</p>

<p>To illustrate the point, imagine we have a function that we know takes a list/array of <em>somethings</em> as input and returns one <em>something</em> as output. We could describe these somethings as "numbers" or "strings" or another "type" as it applies to our case, but if we trust the type system in transform a list of them into just one, we might prefer not to describe what kind of <em>something</em> it is. In those cases, some prefer to use an <code>x</code>, <code>y</code>, <code>a</code> or <code>b</code>, rather than a longer "descriptive" name that does nothing to describe the important part (eg. the transformation from the list of <em>somethings</em> into just one <em>something</em>).</p>

<p>We'll get into Functional Programming more in Chapter 11, but even in a functional context, you might not find single-letter descriptors compelling. That's ok. In this book, we try to avoid that style, but it's worth understanding the justification for the contrarian view on this.</p>
</aside>

<p>When we apply the pattern of thinking of <code>i</code> and <code>j</code> as indices for an argument in a <code>forEach</code> function, then we've really obscured their values. In the <code>setChordCountsInLabels</code> function, <code>i</code> should actually be <code>song</code> (8 replacements), and each instance of <code>j</code> in that function should be <code>chord</code> (5 replacements).</p>

<div data-type="warning" id="flipping-back-5-pages-to-look-at-code-this-is-an-outrage-dYtRUMFv"><h6>Warning</h6>
<h1>Flipping back 5 pages to look at code? This is an outrage!</h1>

<p>Dear reader, I highly recommend at this point that if you haven't already, you become dear <em>writer</em>. If you aren't using your editor to add code and make changes, the code in this and the next chapter will be very hard to follow. In addition to just being good practice (writing code rather than just reading it), the code in this chapter and the next is quite long compared to that found in other chapters.</p>

<p>As written in the preface, it's your book, so you can treat it how you wish, but actually making the changes described, running the code, checking into version control, and writing tests are all part of the skills you should develop through the book.</p>
</div>

<p><code>setProbabilityOfChordsInLabels</code> has <code>i</code> and <code>j</code> variables as well. In this case, <code>i</code> is more appropriately called <code>difficulty</code> (4 replacements) and <code>j</code> is better named as <code>chord</code> (3 replacements). Make those changes, save, check the results, and commit.</p>

<p>For those last two functions, <code>i</code> and <code>j</code> did not represent <em>numerical</em> keys (array indexes), but rather, were <em>string</em> keys of an object. If you weren't sure of more appropriate names, a quick <code>console.log(i)</code> or <code>console.log(j)</code> statement inside of the loop will reveal the values, and hint at a more appropriate name.</p>

<p>This bears reiterating: If you discover true numerical array indexes, the name <code>index</code> (and <code>innerIndex</code> where necessary) are still preferable to single letter variable names. If what you discover are string keys to an object (eg. <code>"easy"</code>, <code>"medium"</code>, <code>"hard"</code> in our case for the <code>i</code> we renamed as <code>difficulty</code>), you should rely on domain knowledge to chose an appropriate name. In those cases, don't worry if your first guess is imprecise. As you gain domain knowledge and confidence in how the program works, you can always rename things again later.</p>

<div data-type="warning" id="renaming-things-can-be-a-big-deal-jQtQTrF1"><h6>Warning</h6>
<h1>Renaming things can be a big deal</h1>

<p>When changing labels, be sure that you change everywhere that needs to be changed. With our single file program, that means every case in the file. With multiple files, lean on your editor/IDE/command line (ack/grep/etc.) to help you find all of the instances.</p>

<p>Also, be sure to give sufficient notice (via deprecation warnings) and allow support for old versions if your code is a module or package external to your project and relied upon by others, although this may be unnecessary for internal values.</p>
</div>

<p>The code is a bit clearer after our renamings, but one object should still stick out as having a short and generic name: <code>obj</code>.</p>

<p>With our method of refactoring first, and understanding after, we don't have a great idea of what <code>obj</code> could mean. Let's take a look at the classify function and see if we can find some hints.</p>

<pre data-type="programlisting">
function classify(chords){
&nbsp; var total = labelProbabilities;
&nbsp; console.log(total);
&nbsp; var classified = {};
&nbsp; Object.keys(total).forEach(function(difficulty){
&nbsp;&nbsp;&nbsp; var first = labelProbabilities[difficulty] + 1.01;
&nbsp;&nbsp;&nbsp; chords.forEach(function(chord){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var probabilityOfChordInLabel =
probabilityOfChordsInLabels[difficulty][chord];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(probabilityOfChordInLabel === undefined){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; first + 1.01;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } else {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; first = first * (probabilityOfChordInLabel + 1.01);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; });
&nbsp;&nbsp;&nbsp; classified[difficulty] = first;
&nbsp; });
&nbsp; console.log(classified);
};
</pre>

<p>We could try to reason it out, but if instead, we cheat a little bit, and add a <code>console.log(obj)</code> after the fifth line (then run with <strong><code>node nb.js</code></strong>), we'll see that "easy," "medium," and "hard" are now printed (in addition to the old output) when we run the program. In some parts of our program, we've been calling these labels, but have just renamed a similar concept as <code>difficulty</code>. Did we make a mistake?</p>

<p>It's not always this easy to find appropriate names for things without the full understanding of the program. <code>label</code> is a name that is more relevant to the algorithm (NBC), but <code>difficulty</code> is more specific to the problem domain (learning to play songs). For now let's change <code>obj</code> to <code>difficulty</code> (4 replacements not including the logging statement). Keep in mind that changing all instances of <code>obj</code> is easy in this case because the name <code>obj</code> is confined not only to this file, but also this function. Feel free to delete the logging statement if you added one.</p>

<p>It is worth considering at this point if adopting the terminology of "difficulty" rather than "label" would make sense for associated variable and function names across the entire program. However, that is a bit more complex as there are a few dozen names that employ that terminology. If you are feeling confident enough to make those changes (the "test" of running the program will cover you, after all), you can do so, but we'll proceed assuming that those names have not been changed. For that reason, it might be worth waiting until you complete this chapter along with the next one before making those changes.</p>
</section>

<section data-type="sect1" id="useless-code-mRsyid">
<h1>Useless Code</h1>

<p>Next up is useless code, and the bottom line is that if you don't need it, get rid of it. If you remember the term YAGNI (Ya ain't gonna need it) from Chapter 1, this is what we're covering in this section.</p>

<p>Here are the forms you might encounter useless code in:</p>

<ul>
	<li>dead code (variables, functions, files, modules, etc)</li>
	<li>comments and speculative code</li>
	<li>whitespace (including EOL, EOF)</li>
	<li>do nothing code (reachable, but has no effect, eg. <code>$($('.someClass'))</code> in jQuery or <code>if(!!booleans)</code>, empty files)</li>
	<li>debugging/logging statements</li>
</ul>

<section data-type="sect2" id="dead-code-1dsaIliP">
<h2>Dead Code</h2>

<p>How do you find dead code? Look for just one instance (project-wide) of a function or variable name. If there's just a function declaration that isn't called anywhere, we can happily delete that function. Same goes for variables that aren't used. Keep in mind that this would be harder to ensure if our program went beyond one file. Make sure you have a good way to search through a whole project either on the command line or through your editor.</p>

<p>Can you find any instances of dead code in our NBC?</p>

<p>There are actually three variables that we can eliminate. Neither <code>army</code> nor <code>blankSong</code> are used as training data (or anywhere else), so the lines with those variable declarations can be safely deleted. A Save/Run/Check/Commit cycle shows us that we haven't broken anything (the result is the same).</p>
</section>

<section data-type="sect2" id="speculative-code-and-comments-9ZsMumir">
<h2>Speculative Code and Comments</h2>

<p>Sometimes you'll see comments that are intended as future code (a stub, psuedocode, or a full implementation). This is the deadest of dead code, and any details of what code <em>should</em> be there are best left to some task management system that shares ToDos (and more formally "tickets"/"tasks"/"bugs") with the team. The codebase is for real, running code. Speculative code, commented out or not, violates the "YAGNI" (Ya Ain't Gonna Need It) principle. If the code reflects not only its functionality, but somehow all of its potential, it is due to be pruned. An additional danger with commented code is that one might assume that it actually should work if uncommented. It may work or not. If it is not exercised by tests or even running with the rest of the code, it should not be trusted.</p>

<p>We can delete our first line: <code>var fs = require('fs')</code></p>

<p>Apparently, there was an intention to include and make use of the file system module at some point, but it was never realized. If you are not actively working on some file system based feature, then this should go. Currently. If you see something like this, especially with an accompanying comment:</p>

<pre data-type="programlisting">
// use the file system for *something* later
var fs = require('fs')</pre>

<p>Then it is dead code of a particular type: "speculative code." Maybe <code>army</code> and <code>blankSong</code> were speculative as well. The difference is intention, which is hard to tell without comments, supporting tests, or domain knowledge. You might also say they're not dead code because they do something (assign a couple of variables) whereas "real" dead code is unreachable/impossible to execute. For our purposes here, it doesn't matter. We treat all those cases the same: delete the code.</p>

<p><em>Don't just comment it out.</em> Any reasonably complex project should have some way of keeping track of future intentions (a bug list, feature tickets or "user stories", etc.). If you comment it out, your code is taking on extra work that it shouldn't.</p>
There are two useful approaches to problematic comments. The first is simply to delete them. The second is to use them as inspiration for creating a variable or function. Our second line <code>//songs</code> is a candidate for creating a variable or function (<em>explaining comments</em> often indicate a good place to extract a function or variable), but in this section, we're just covering that which can be deleted. Feel free to delete this line for now, and Save/Run/Check/Commit the code.

<p>&nbsp;</p>

<aside data-type="sidebar" id="documentation-when-comments-are-useful-RLHyhkujij">
<h5>Documentation: When comments are useful</h5>

<p>In any code of sufficient complexity and likelihood of being used by others, comments can be useful as documentation. These typically preceed functions and classes (or objects) and describe what the function does, as well as the explicit parameters and return type. They may even be responsible for helping to build external documentation. Obviously, we don't want to delete those comments in the source files (compiled/minified files should strip these to make files smaller).</p>

<p>ReadMes and tutorials can serve as a type of documentation as well, but high-quality descriptions of how code works, living as comments in the source files is especially useful.</p>

<p>Another interesting use of comments on the front-end, is to send secret messages to those who would "view the source." Usually this involves ascii art and "Hey developers! Work for us!" type notes.</p>
</aside>
</section>

<p>&nbsp;</p>

<section data-type="sect2" id="whitespace-P0sncein">
<h2>Whitespace</h2>

<p>The whitespace in our code seems alright for the most part. Before the <code>classify</code> function, there are three blank lines, two of which can and should be deleted. Beyond extra blank lines, you may see trailing white space at the end of a line. This shows up in a different (and usually distracting) color in some editors, and doesn't in others. How much you dislike this trailing, meaningless whitespace probably has to do with what editor (and settings for that editor) you use. You should feel free to delete it in most cases, but it will make your <strong><code>git diff</code></strong> (the set of changes to a project) potentially much larger, a distraction of a different type.</p>

<p>Another, somewhat editor-specific whitespace instance comes from a blank line at the end of a file. Generally, this seems like a good idea (ie. it follows the IEEE POSIX standard for what a "file" is), but can lead to version control noise/conflicts if two developers have different editors or personal preferences (as in the previous paragraph).</p>
</section>

<section data-type="sect2" id="do-nothing-code-n3sQS9in">
<h2>Do Nothing Code</h2>

<p>Moving on to "do nothing code," we have an example of this in our file. The conditional check that follows contains an unnecessary part:</p>

<pre data-type="programlisting">
if(!!(Object.keys(labelCounts).includes(label))){</pre>

<p>Specifically, the <code>!!</code> can go away, leaving:</p>

<pre data-type="programlisting">
if(Object.keys(labelCounts).includes(label)){</pre>

<p>Make that change and save/run/check/commit.</p>

<p>Since the <code>includes</code> function already returns a boolean, there is no need to use <code>!!</code> to "cast" it to one. In case you're wondering how this works, a <em>unary</em> <code>!</code> gives returns the inverted "truthiness" of a value. You can try these out in a console if you're curious:</p>

<pre data-type="programlisting">
!true // returns false
!!true // returns true
!![] // returns true
!!0 // returns false
</pre>

<p>A second reason this <code>!!</code> is unneeded here is that, although explicitly setting a boolean might seem to make sense, for any value that is tested in an <code>if</code> statement, you can expect the if branch to be followed for true (and else for false) values without explicitly coercing the boolean. So the following snippet would print "hi", because non-empty strings are "truthy" in JavaScript.</p>

<pre data-type="programlisting">
if("print hi"){ console.log('hi')}</pre>

<div data-type="note" id="falsey-values-in-javascript-mQtGh1SPij"><h6>Note</h6>
<h1>Falsey Values In JavaScript</h1>

<p>There are six "falsey" values in JavaScript: <code>undefined</code>, <code>null</code>, <code>0</code>,&nbsp;<code> ""</code> (the empty string), <code>NaN</code>, and <code>false</code>. Applying <code>!!</code> of these will produce a <code>false</code>,&nbsp; whereas other strings, numbers, objects, functions, arrays, etc. will all produce a <code>true</code>.</p>
</div>

<p>Back to unnecessary code, there is no need to <code>!!</code> values in an <code>if</code> statement test as we did. If you are looking for a use for the <code>!!</code>, one way to use it appropriately would be in front of a return value of a function that you want to return a boolean. Here is a contrived example:</p>

<pre data-type="programlisting">
function didItWork(){
  return !!numberOfTimesItWorked();
};
</pre>

<p>Here, we have access to a function of the number of times something worked. If it happened 0 times, then we want to return a <code>false</code>. If it happened more than that, we want to return a <code>true</code>.</p>

<p>One other example from our classifier is related to how JavaScript handles numbers. Specifically, there aren't "integers" and "floats," just numbers. In some languages (such as Ruby), these give different results:</p>

<pre data-type="programlisting">
10 / 3 # this returns 3
10.0 / 3 # this returns 3.33333...
</pre>

<p>So if you're coming from a language like Ruby, in a calculation that involves an integer values of <code>10</code> and <code>3</code>, at least one value has to be converted into a float first. This can be done by multiplying one of the terms by <code>1.0</code>.</p>

<p>In most JavaScript, <em>floats</em> and <em>integers</em> are both just <em>numbers</em>, so both of the above division expressions produce <code>3.3333...</code> No explicit conversion is needed. That means that we have another unnecessary bit of code in our classifier. The following line is able to drop the <code>* 1.0</code> part:</p>

<pre data-type="programlisting">
probabilityOfChordsInLabels[difficulty][chord] = 
probabilityOfChordsInLabels[difficulty][chord] * 1.0 / songs.length;</pre>

<p>making it:</p>

<pre data-type="programlisting">
probabilityOfChordsInLabels[difficulty][chord] = 
probabilityOfChordsInLabels[difficulty][chord] / songs.length;
</pre>

<p>Another example of do nothing code: The <code>total</code> variable that we spent a bit of time earlier renaming. It's due for deletion. Why? All it does is receive an assignment and log something. We can just log <code>labelProbabilities</code> directly.</p>

<p>Change this section of code:</p>

<pre data-type="programlisting">
function classify(chords){
&nbsp; var total = labelProbabilities;
&nbsp; console.log(total);
&nbsp; var classified = {};
&nbsp; Object.keys(total).forEach(function(difficulty){</pre>

<p>to this:</p>

<pre data-type="programlisting">
function classify(chords){
&nbsp; console.log(labelProbabilities);
&nbsp; var classified = {};
&nbsp; Object.keys(labelProbabilities).forEach(function(difficulty){</pre>

<p>Save/Run/Check/Commit to confirm we haven't changed how the program works.</p>

<p>Where else does unnecessary code pop up? We don't have an example of this in our classifier, but another way code can be useless is by double wrapping itself like in the following jQuery snippet:</p>

<pre data-type="programlisting">
$('input').on('click', function(){
  var elementToHide = $(this);
  $(elementToHide).hide();
});</pre>

<p>The value of <code>this</code> in that example gets wrapped into a jQuery object twice. jQuery is smart enough to ignore this, but the second wrapping of <code>elementToHide</code> with a dollar sign is not needed.</p>

<pre data-type="programlisting">
$('input').on('click', function(){
&nbsp;&nbsp;var elementToHide = $(this);
&nbsp; elementToHide.hide();
});
</pre>

<p>Whether to a boolean, a float, a jQuery object, or something else, you'll see these multiple/unnecessary conversion efforts every once in a while.</p>

<p>We'll look at unnecessary variables more in the next section (we actually already had one earlier when we logged the <code>labelProbabilities</code> variable directly and removed <code>total</code>), but notice that in the jQuery example, <code>elementToHide</code> is not actually needed with the following change:</p>

<pre data-type="programlisting">
$('input').on('click', function(){
&nbsp; $(this).hide();
});
</pre>

<p>Back to the NBC, another section of our code that is useless appears here:</p>

<pre data-type="programlisting">
&nbsp;if(probabilityOfChordInLabel === undefined){
&nbsp;&nbsp; first + 1.01;
&nbsp;} else {
&nbsp;  first = first * (probabilityOfChordInLabel + 1.01);
&nbsp;}
</pre>

<p>The true branch of this <code>if</code> statement may run, but it does not return anything or have any side effects (such as an assignment to a variable). The only thing this branch <em>could</em> do is throw an error if, for instance, <code>first</code> was <em>not defined</em> (not to be confused with having the <em>value</em> of <code>undefined</code>) for some reason. This is not "dead code," but it happens to be useless. We're safe to simplify this code to be the following:</p>

<pre data-type="programlisting">
if(probabilityOfChordInLabel !== undefined){
  first = first * (probabilityOfChordInLabel + 1.01);
}
</pre>

<p>Notice that we flipped the conditional, because all we care about is the <code>else</code> case.</p>

<p>While we're at it, as far as the conditional <em>test</em> (what is inside the parens) goes, all we really care about is that <code>probabilityOfChordInLabel</code> is truthy. We're not actually concerned with it being <em>not</em> <code>undefined</code>. Our conditional is overly specific (in a "useless" way) and that means we can do this instead:</p>

<pre data-type="programlisting">
if(probabilityOfChordInLabel){
  first = first * (probabilityOfChordInLabel + 1.01);
}</pre>

<p>If we didn't have a testing procedure in place, this change would be a bad idea. In our case, everything looks normal when we run the code, so assuming we're confident in the testing procedure, we're in the clear.</p>

<div data-type="note" id="duplication-in-conditionals-another-type-of-useless-code-rQtnH6SXiY"><h6>Note</h6>
<h1>Duplication in conditionals: Another type of useless code</h1>

<p>Occasionally you might encounter a conditional like this:</p>

<pre data-type="programlisting">
if(dog.weight &gt; 40){
  buyFood('big bag');
  dog.feed();
}
else{
&nbsp;&nbsp;buyFood('small bag');
  dog.feed();
}</pre>

<p>We're going to feed the dog no matter how big it is, so there's no need to say it twice.</p>

<pre data-type="programlisting">
if(dog.weight &gt; 40){
&nbsp;&nbsp;buyFood('big bag');
}
else{
&nbsp;&nbsp;buyFood('small bag');
}
dog.feed();
</pre>
By the way, we have ways to eliminate this conditional altogether. We'll look at a few options in Chapter 9.</div>
</section>

<section data-type="sect2" id="debugginglogging-statements-GMsGtliz">
<h2>Debugging/Logging Statements</h2>

<p>The last type of useless code is debugging/logging statements. If you don't have any automated tests in place (our situation in this chapter), these can be helpful initially. It's when someone forgets to delete them that they can become a problem. They're actually worse than useless, because they can cause errors or make for broken and/or awkward user experiences.</p>

<p>Currently, we're relying on these for our manual testing process, but in the next chapter, we'll replace them with proper automated tests.</p>
</section>

<p>&nbsp;</p>
</section>

<section data-type="sect1" id="variables-jgs3Hn">
<h1>Variables</h1>

<p>Now that we have poorly named and useless code out of the way, things are going to get a bit trickier. Here are the techniques we'll be looking at:</p>

<ul>
	<li>Magic Numbers</li>
	<li>Long Lines: Part 1</li>
	<li>Inlining function calls</li>
	<li>Introducing a Variable</li>
	<li>Variable Hoisting (Including a discussion of Function Hoisting)</li>
</ul>

<section data-type="sect2" id="magic-numbers-1dsof1HP">
<h2>Magic Numbers</h2>

<p>"Magic Numbers" are numbers that are hardcoded into the app. They're called "magic," because they seem to appear out of nowhere. Most of our numbers in the classifier are either <code>1</code> or <code>0</code>. Those aren't magical enough to deserve names. Both are used as array indexes and 1 is used to set and increment counters.</p>

<p>One other number stands out as sufficiently magical: <code>1.01</code> in the <code>classify</code> function. When dealing with magic numbers, they should be named and declared in the smallest scope possible (we'll deal with scopes more in the next chapter). If they are used throughout, adding them to the top-level scope (creating a "global" variable), might <em>seem</em> like a bad option at first. It's not great for reasons we've discussed a bit in earlier chapters, but (if it's confined to one file) it's still better than having the same magic number spread across the code.</p>

<p>This time though, the magic number is confined to our <code>classify</code> function. That means we can add our variable to the top of that function, and replace all of the <code>1.01</code> instances with the variable name. As far as what to call the variable, we're going to have to break our illusion of having zero knowledge of NBC algorithm here and admit that this variable should be called "smoothing." Basically, it helps to keep zeros from blowing up our algorithm (NBC relies on multiplying likelihoods together, so if one of them is zero it can zero out a whole label/difficulty). In any case, this is the function after it is changed:</p>

<pre data-type="programlisting">
function classify(chords){
&nbsp; var smoothing = 1.01;
&nbsp; console.log(labelProbabilities);
&nbsp; var classified = {};
&nbsp; Object.keys(labelProbabilities).forEach(function(difficulty){
&nbsp;&nbsp;&nbsp; var first = labelProbabilities[difficulty] + smoothing;
&nbsp;&nbsp;&nbsp; chords.forEach(function(chord){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var probabilityOfChordInLabel = 
probabilityOfChordsInLabels[difficulty][chord]
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(probabilityOfChordInLabel){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; first = first * (probabilityOfChordInLabel + smoothing)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp; })
&nbsp;&nbsp;&nbsp; classified[difficulty] = first
&nbsp; });
&nbsp; console.log(classified);
};

</pre>

<p>Besides the lack of explanation that comes with magic numbers (they usually have most of the same drawbacks as poorly named variables), they also resist change by not having a singular place to alter their value as necessary. For example, if you were making a game, and set the gravitational constant to 9.8 meters per second squared (as a magic number spread across the code), building a new level that takes place on the moon means hunting down all of those instances of <code>9.8</code> rather than just changing a variable in one place. The alternative being not changing it, and missing a cool feature in an otherwise awesome game (looking at you DuckTales for the NES).</p>

<p>On a related note, magic <em>strings</em> can be just as bad, or worse. When user-facing strings are hard-coded, it's quite possible for this to be no problem whatsoever, partly because strings tend to explain themselves a bit better than numbers. But if you decide to localize into a few languages, you'll likely begin to think of them as a problem.</p>

<p>We have two types of strings: names of chords and difficulty levels. As for the names of chords, there is such a variety in them that they are not prone to be reusable. Additionally, the complexity and interrelations of the data they represent mean that storing each string as a variable would be unlikely to improve anything. Perhaps a string is not the best representation of this data, but the fix of converting them (and the functions that operate on them) to a new type of object is beyond the simple refactoring of labeling magic strings.</p>

<p>As for the difficulty levels, these are indeed magic strings. They are repeated, and we can imagine a case where we would want to change, for example, all instances of "medium" to "intermediate," or "easy" to "beginner." Let's address that with global (top-level defined) variables for now.</p>

<p>Just declare this at the top of the file:</p>

<pre data-type="programlisting">
var easy = 'easy';
var medium = 'medium';
var hard = 'hard';
</pre>

<p>And then change instances of <code>'easy'</code> to <code>easy</code>, <code>'medium'</code> to <code>medium</code>, and <code>'hard'</code> to <code>hard</code> in the rest of the program, removing the quotes. Note that we created global variables here, which is not great, but still better than having repeated string literals littered throughout the program.</p>

<p>Save/Run/Check/Commit. All good? Great.</p>
</section>

<section data-type="sect2" id="long-lines-part-1-9ZskI9Hr">
<h2>Long Lines: Part 1</h2>

<p>Next up: fixing long lines by adding variables, part 1 (we'll cover other ways later).</p>

<pre data-type="programlisting">
probabilityOfChordsInLabels[difficulty][chord] = probabilityOfChordsInLabels[difficulty][chord] / songs.length;
</pre>

<p>This line is too long (it might not even fit on whatever medium you're using to read this). To shorten it, we <em>could</em> introduce a new variable with a descriptive name:</p>

<pre data-type="programlisting">
var chordInstances = probabilityOfChordsInLabels[difficulty][chord];
probabilityOfChordsInLabels[difficulty][chord] = 
chordInstances / songs.length;
</pre>

<p>Even then, the second assignment spills onto two lines, admittedly with a fairly tight restriction. We could also use a shorter name like this:</p>

<pre data-type="programlisting">
crdPrb[difficulty][chord] = crdPrb[difficulty][chord] / songs.length;</pre>

<p>But that's not really great because now we have a less clear variable name.</p>

<p>One other option is what we discussed near the beginning of the chapter, just breaking at the assignment into two lines:</p>

<pre data-type="programlisting">
probabilityOfChordsInLabels[difficulty][chord] =
probabilityOfChordsInLabels[difficulty][chord] / songs.length;</pre>

<p>However, we have a better option. We can make use of a shorthand function. If <code>/</code> was a more complicated operation, introducing a variable as above (or a function) would make sense, but for this, we can make use of JavaScript's <code>/=</code> operator.</p>

<pre data-type="programlisting">
probabilityOfChordsInLabels[difficulty][chord] /=&nbsp; songs.length;
</pre>

<p>This is equivalent, but significantly shorter than our first version. We can apply a similar change to this line:</p>

<pre data-type="programlisting">
chordCountsInLabels[song[0]][chord] = chordCountsInLabels[song[0]][chord] + 1;
</pre>

<p>This time we'll use a similar shorthand, in the more familiar <code>+=</code> operator:</p>

<pre data-type="programlisting">
chordCountsInLabels[song[0]][chord] += 1;
</pre>

<p>Then we save, run, check, and commit.</p>
</section>

<section data-type="sect2" id="inlining-function-calls-VZsPu1HP">
<h2>Inlining Function Calls</h2>

<p>Next up, we'll look specifically at <em>inlining</em> function calls and avoiding setting unneeded variables. In the following two functions, how much is really needed?</p>

<pre data-type="programlisting">
function getNumberOfSongs(){
&nbsp; return songs.length;
};

function setLabelProbabilities(){
&nbsp; Object.keys(labelCounts).forEach(function(label){
&nbsp;&nbsp;&nbsp; var numberOfSongs = getNumberOfSongs();
&nbsp;&nbsp;&nbsp; labelProbabilities[label] = labelCounts[label] / numberOfSongs;
&nbsp; });
};
</pre>

<p>Assuming that <code>getNumberOfSongs</code> is only called by <code>setLabelProbabilities</code>, we have an opportunity to "inline" the function. What this means is that we take it's body, and replace the call to the function with it.</p>

<pre data-type="programlisting">
function getNumberOfSongs(){
&nbsp;&nbsp; return songs.length;
};

function setLabelProbabilities(){
&nbsp; Object.keys(labelCounts).forEach(function(label){
&nbsp;&nbsp;&nbsp; var numberOfSongs = songs.length;
&nbsp;&nbsp;&nbsp; labelProbabilities[label] = labelCounts[label] / numberOfSongs;
&nbsp; });
};</pre>

<p>One caveat here is that any local variables used in <code>getNumberOfSongs</code> would need to be accessible in <code>setLabelProperties</code> as well. Since in this case, it only relies on the shared, non-local variable <code>songs</code>, no additional changes are required to make it available to <code>setLabelProperties</code>. Also, note that if <code>getNumberOfSongs</code> took explicit parameters, made use of an implicit <code>this</code>, or was called elsewhere in the code, we might have additional challenges with inlining and removing it.</p>

<p>Now that no code is calling <code>getNumberOfSongs</code>, we are free to delete this "dead code." Leaving us just this function:</p>

<pre data-type="programlisting">
function setLabelProbabilities(){
&nbsp; Object.keys(labelCounts).forEach(function(label){
&nbsp;&nbsp;&nbsp; var numberOfSongs = songs.length;
&nbsp;&nbsp;&nbsp; labelProbabilities[label] = labelCounts[label] / numberOfSongs;
&nbsp; });
};
</pre>

<p>If you find that the result of a function is just being set as a variable (<code>numberOfSongs</code> in this case), it is a good candidate for inlining/removing. If the resultant variable is only used once, then it's not a performance concern, and you have good reason to drop the variable altogether, leading to the following:</p>

<pre data-type="programlisting">
function setLabelProbabilities(){
&nbsp; Object.keys(labelCounts).forEach(function(label){
&nbsp;&nbsp;&nbsp; labelProbabilities[label] = labelCounts[label] / songs.length;
&nbsp; });
};</pre>

<p>Five lines instead of nine seems better.</p>

<p>Save/run/check/commit. All good?</p>
</section>

<section data-type="sect2" id="introducing-a-variable-P0spTRHn">
<h2>Introducing a Variable</h2>

<p>Variables are not as flexible as functions. If we want to "introduce a function" inline, then pass the relevant local state through explicit parameters, we can move the function out of the scope it was derived from without too much trouble. Because the parameters are explicit, our function doesn't have any state to worry about reproducing or holding. If you "extract" a variable, you're likely increasing its scope and responsibilities (and that puts you on course to global variables), whereas with functions, they can be extracted, while retaining their flexibility and reliability.</p>

<p>In other words, we can think of "extracting" as a specific type of "introducing" that is more appropriate for functions than variables in many cases.</p>

<p>For this section, we're going to leave our NBC temporarily and demonstrate introducing variables in the same scope as the context as the code they're replacing. Later, we'll talk a bit more about extraction.</p>

<div data-type="note" id="introducing-variables-is-sometimes-not-awesome-K8trIgTKHz"><h6>Note</h6>
<h1>Introducing variables is sometimes not awesome</h1>

<p>In the sample below, we show how to extract a variable, and then immediately show a better way of handling the same problem. Although introducing variables might be a good approach as a simple way to "cache" the result of a calculation (especially while experimenting with changes), there are often more sophisticated approaches to improve your interface (extracting/chaining/composing functions) or performance (using <em>memoized</em> functions or some persistent caching mechanism).</p>

<p>Overall, you have a lot of options.</p>
</div>

<p>Leaving our NBC for a minute, hopefully, you don't use code like this to print out an array:</p>

<pre data-type="programlisting">
console.log(someArrayReturningGetterFunction()[0]);
console.log(someArrayReturningGetterFunction()[1]);
console.log(someArrayReturningGetterFunction()[2]);
console.log(someArrayReturningGetterFunction()[3]);
</pre>

<p>Besides the repetition in the code, you're also running the function four times.</p>

<p>In spite of that looking bad to most people, you'll often see jQuery code like this in the wild:</p>

<pre data-type="programlisting">
$('#someDomElement').css('width', 5);
$('#someDomElement').css('background-color', 'red');
$('#someDomElement').show();
</pre>

<p>Some jQuery DOM selections and mutations are expensive (computationally). For that reason, the following is preferable:</p>

<pre data-type="programlisting">
var domElement = $('#someDomElement');
domElement.css('width', 5);
domElement.css('background-color', 'red');
domElement.show();
</pre>

<p>Here, we're introducing a "caching" variable, because the code only has to perform the query (to get the html element with the id of <code>someDomElement</code>) one time. We can apply this same technique in JavaScript generally.</p>

<p>However, be aware that functions on jQuery's <code>$</code> object actually have a special feature that makes this unnecessary. It is called "chaining" function calls.</p>

<pre data-type="programlisting">
$('#someDomElement')
.css('width', 5)
.css('background-color', 'red')
.show();
</pre>

<p>We just <em>chain</em> the functions together. This works because each function returns <code>this</code> along with the modifications made by the function. By the way, jQuery let's us simplify this just a bit more by accepting an object to css:</p>

<pre data-type="programlisting">
$('#someDomElement')
.css({'width': 5, 'background-color', 'red'})
.show();
</pre>

<p>Chaining functions has a battle fought hard on the async front, which we will discuss more in Chapter 10. Additionally, refer back to the discussion of fluent interfaces in Chapter 5.</p>

<aside data-type="sidebar" id="enough-jquery-already-JqHOIXTmHE">
<h5>Enough jQuery already!</h5>

<p>It's dead! No one uses it. React and Ember and Meteor and Angular and Vanilla all make it obsolete. Or maybe not. As far as I (the past me from your perspective now, which is kind of like the future to me as I write this) am concerned, you're reading this in the future after all. Maybe jQuery is all the rage now.</p>

<p>Although personally, as of this writing, I think jQuery is still relevant and suitable for simple web pages, there are three practical reasons for using it here.</p>

<ul>
	<li>If you're working on a legacy web project, it's very likely to have jQuery</li>
	<li>If you're working on a legacy web project with jQuery, it's very likely to have the exact kinds of nonsense shown here.</li>
	<li>Because jQuery is so closely tied to the DOM, it's extremely common to see very procedural code that relies heavily on side-effects. Because of how many people use it, it is among the worst JavaScript that you'll see.</li>
</ul>
</aside>
</section>

<section data-type="sect2" id="variable-hoisting-n3sBcmHn">
<h2>Variable Hoisting</h2>
Now onto our last topic for variables: declaring variables where they are hoisted to. JavaScript has an esoteric feature called "hoisting." Variables declared with <code>var</code> or <code>function</code> are actually initialized as <code>undefined</code> at the top of the <em>function</em> scope in which you declare them. We'll get more into <code>var</code>, <code>let</code>, and <code>const</code> in the next chapter, but for now, it is worth noting a fairly JavaScript-specific refactoring regarding hoisting that we may want to use on our classifier.

<p>With our changes from before, our <code>train</code> function should look like this:</p>

<pre data-type="programlisting">
function train(chords, label){
&nbsp; songs.push([label, chords]);
&nbsp; labels.push(label);
&nbsp; for (var index = 0; index &lt; chords.length; index++){
&nbsp;&nbsp;&nbsp; if(!allChords.includes(chords[index])){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; allChords.push(chords[index]);
&nbsp;&nbsp;&nbsp; }
&nbsp; }
&nbsp; if(Object.keys(labelCounts).includes(label)){
&nbsp;&nbsp;&nbsp; labelCounts[label] = labelCounts[label] + 1;
&nbsp; } else {
&nbsp;&nbsp;&nbsp; labelCounts[label] = 1;
&nbsp; }
};
</pre>

<p>If we find it confusing (or think others on the team will) that JavaScript is hoisting our variable and want to prevent that confusion, we can move the index variable to the top of the function.</p>

<pre data-type="programlisting">
function train(chords, label){
  var index; //same as: var index = undefined;
&nbsp; songs.push([label, chords]);
&nbsp; labels.push(label);
&nbsp; for (index = 0; index &lt; chords.length; index++){
...
</pre>

<p>In looking at the <code>classify</code> function, it might seem like we could do some hoisting there as well. But in actuality, each variable is already declared (and assigned) right at the top of their functional scope, almost. Take a look:</p>

<pre data-type="programlisting">
function classify(chords){
&nbsp; var smoothing = 1.01;
&nbsp; console.log(labelProbabilities);
&nbsp; var classified = {};
&nbsp; Object.keys(labelProbabilities).forEach(function(difficulty){
&nbsp;&nbsp;&nbsp; var first = labelProbabilities[difficulty] + smoothing;
&nbsp;&nbsp;&nbsp; chords.forEach(function(chord){
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; var probabilityOfChordInLabel = probabilityOfChordsInLabels[difficulty][chord]
...
</pre>

<p>If you want to move <code>var classified = {};</code> above the <code>console.log</code>, go for it. Otherwise we're all set.</p>

<p>Since anonymous functions <em>also</em> create scopes, <code>first</code> is declared at the top of its <em>function</em> scope, and so is <code>probabilityOfChordInLabel</code>. Before, when we introduced the <code>smoothing</code> variable (as a solution to the "magic number" problem), we happened to put it into the hoisted position.</p>

<aside data-type="sidebar" id="function-hoisting-y8HqUkcgHD">
<h5>Function hoisting</h5>

<p>Before leaving the topic of hoisting, it's worth noting that there is a difference between the following two function declarations:</p>

<pre data-type="programlisting">
function myCoolFunction(){};
//and
var myCoolFunction = function(){};</pre>

<p>The first one (the style of declaration we're using in this classifier) is hoisted to the top of its function scope, and because this is declared at the top-level, that means the top of the file. The whole function is hoisted to the top. That means that if you want to run the following, there's nothing stopping you:</p>

<pre data-type="programlisting">
classify(['d', 'g', 'e', 'dm']);
function classify(chords){
  ...
};
</pre>

<p>However, if you try that with the second form of <code>myCoolFunction</code>, only the label <code>myCoolFunction</code> is hoisted and initialized to <code>undefined</code>. It doesn't even know it's a function yet, so this won't work:</p>

<pre data-type="programlisting">
classify(['d', 'g', 'e', 'dm']);
var classify = function(chords){
&nbsp;&nbsp;...
};
// TypeError: classify is not a function</pre>

<p>The <code>classify</code> <em>variable</em> is hoisted, but its assignment (the <em>function</em>) is not.</p>

<p>In the "no no" case of declaring a variable (even a function) without a <code>var</code> (or other scoping variables like <code>let</code> and <code>const</code>), it will not be hoisted, but when that line hits, it will be in the top-level scope (or <code>undefined</code> in strict mode).</p>

<p>This knowledge matters because if we decide to have hoisted functions, we can end up having our demonstration, assertion, or testing code at the top, which may be convenient. Picture something like this at the very top of the file:</p>

<pre data-type="programlisting">
train(getTrainingSet());
classify(getNewSong());
</pre>

<p>It's certainly not essential and possibly not your style, but knowing about hoisting is critical to supporting this type of "public interface first" structure, as well as promoting general confidence in your ability to reorder your code as you see fit.</p>

<p>One last thing to note is that this is about as short as you can make a <em>function declaration</em>:</p>

<pre data-type="programlisting">
function add(x, y){ return x + y };
</pre>

<p>Compare that to the slightly shorter anonymous <em>function expression</em> getting assigned to a variable:</p>

<pre data-type="programlisting">
var add = (x, y) =&gt; x + y;
</pre>

<p>For one-liners, this second form is nice, but keep hoisting rules in mind. Also, and this is a minor point, but because this second form is anonymous (even though it has a variable that you can reference it through), the function object property <code>name</code> is not, as of this writing, supported on all environments.</p>
</aside>

<p>&nbsp;</p>
</section>
</section>

<section data-type="sect1" id="strings-qYsjCb">
<h1>Strings</h1>

<p>In this section, we're looking at refactorings that we can use for strings. Here are the things we'll cover:</p>

<ul>
	<li>Concatenating, Magic, and Template Strings</li>
	<li>Regex Basics for Handling Strings</li>
	<li>Long Lines: Part 2 (Strings)</li>
</ul>

<section data-type="sect2" id="concatenating-magic-and-template-strings-9ZsZfqCr">
<h2>Concatenating, Magic, and Template Strings</h2>

<p>Let's say that when we run our code, we want to output "Welcome to " plus the name of our file through <code>console.log</code>.</p>

<p>We can start by adding this code to the top of our file:</p>

<pre data-type="programlisting">
console.log('Welcome to nb.js!'); </pre>

<p>This will work fine, but the file name does remind us of a Magic String, doesn't it? First, we can separate the parts out with the <code>+</code> operator.</p>

<pre data-type="programlisting">
console.log('Welcome to ' + 'nb.js' + '!'); 
</pre>

<p>Then we can move our Magic String into a filename variable.</p>

<pre data-type="programlisting">
var fileName = 'nb.js';
console.log('Welcome to ' + fileName + '!');
</pre>

<p>Note that if you want to use this for our current file, that this additional output breaks our manual test in that it adds output that was not previously there.</p>

<p>And one last tweak we can make here is to use <em>template strings</em>, instead of concatenating with the <code>+</code> operator.</p>

<pre data-type="programlisting">
var fileName = 'nb.js';
console.log(`Welcome to ${fileName}!`);
</pre>

<p>Instead of using single or double quotes, we use backticks (<code>`</code>) for the string, and then "interpolate" any JavaScript (not just variables) in between the <code>${}</code>. As evidence that this would work just as well with arbitrary JavaScript and not just a variable name, try using it with a function like this:</p>

<pre data-type="programlisting">
function fileName(){
&nbsp; return 'nb.js';
};
console.log(`Welcome to ${fileName()}!`);
</pre>

<p>In any case, it seems a little weird that we have to explicitly set the filename, doesn't it? Does JavaScript have anything like <code>__FILE__</code> that is a common feature in other languages that will simply tell us the name of the file we're in?&nbsp;</p>

<p>As of this writing, it doesn't, but hopefully by the time you're reading this, it does. The current solution is shocking. Add this to the top of your file:</p>

<pre data-type="programlisting">
var theError = new Error("here I am");
console.log(theError);
</pre>

<p>Now you get a stack trace, that includes the filename, line, and column number where the error was thrown.</p>

<pre data-type="programlisting">
Error: here I am
&nbsp;&nbsp;&nbsp; at Object.&lt;anonymous&gt; (.../refactoring.js/bayes/nb.js:1:78)
&nbsp;&nbsp;&nbsp; at Module._compile (module.js:541:32)
&nbsp;&nbsp;&nbsp; at Object.Module._extensions..js (module.js:550:10)
&nbsp;&nbsp;&nbsp; at Module.load (module.js:458:32)
&nbsp;&nbsp;&nbsp; at tryModuleLoad (module.js:417:12)
&nbsp;&nbsp;&nbsp; at Function.Module._load (module.js:409:3)
&nbsp;&nbsp;&nbsp; at Function.Module.runMain (module.js:575:10)
&nbsp;&nbsp;&nbsp; at startup (node.js:160:18)
&nbsp;&nbsp;&nbsp; at node.js:449:3</pre>

<p>After digging around in the error object a bit:</p>

<pre data-type="programlisting">
typeof theError === 'object';
Object.getOwnPropertyNames(theError)
typeof theError.message === 'string'
typeof theError.stack === 'string'
</pre>

<p>You'll find that <code>theError</code> has two properties: a <code>stack</code>, and a <code>message</code>. Both properties are strings. <code>stack</code> is what we're interested in, specifically the filename in it.&nbsp;</p>
</section>

<section data-type="sect2" id="regex-basics-for-handling-strings-VZsoIlCP">
<h2>Regex Basics For Handling Strings</h2>

<p>It appears that the filename will have a slash before, and a colon after, which is unique among other file and folder names in the <code>stack</code>. We can imagine some convoluted function containing <code>for</code> loop that adds letters to a string and then shaves off the slash and colon before returning it. Or, somewhat more intelligently, we could use a few string and array methods to zero in on what we want. Let's redefine our <code>fileName</code> function like the following:</p>

<pre data-type="programlisting">
function fileName(){
  var theError = new Error("here I am");
  return theError.stack.split('\n')[1].split('/').pop().split(':')[0];
};
</pre>

<p>It is definitely better than the <code>for</code> loop idea, but it feels a little... inelegant.</p>

<p>Regex to the rescue. Make the top of the file look like this:</p>

<pre data-type="programlisting">
function fileName(){
&nbsp; var theError = new Error("here I am");
&nbsp; return /\/(\w+\.js)\:/.exec(theError.stack)[1];
};
console.log(`Welcome to ${fileName()}!`);
</pre>

<p>Why is this better? Because despite the syntax looking weird if you're not used to it, this maps better to how we initially thought of the problem (pull characters matching this pattern vs. breaking up strings and substrings to select from). The pattern we're matching starts with a slash (<code>\/</code>). It's followed by some number of word characters (<code>\w+</code>) and .js (<code>\.js</code>), ending with a colon (<code>\:</code>). Regex's <code>exec</code> function happens to return an array, with the whole match as the first element, and the stuff we care about <code>(\w+\.js)</code> as the second one. The parens in the regex let us get specific about what we want (this use of parens is known as the "capture" in regex terms) vs. what we use to match the pattern overall.</p>

<p>Save/Run/Check/Commit.</p>

<p>Basically, any time you find yourself searching and/or replacing text, don't think of parsing with <code>for</code> loops or working with <code>split</code> to make arrays. Or do, until it gets complicated, and then use a regex.</p>

<div data-type="note" id="regex-vs-string-apis-dYt3tmI9Co"><h6>Note</h6>
<h1>Regex vs. String APIs</h1>

<p>One thing that is a bit confusing is that some functions are defined on regex objects and others are defined on strings.</p>

<p>Regex has the <code>exec</code> and <code>test</code> methods. <code>test</code> works just like <code>exec</code> except it returns a boolean, rather than a match data array. String's <code>match</code> is the flip side to <code>exec</code>, so our function could also be:</p>

<pre data-type="programlisting">
function fileName(){
&nbsp; var theError = new Error("here I am");
&nbsp; return theError.stack.match(/\/(\w+\.js)\:/)[1];
};
</pre>
</div>
</section>

<p>&nbsp;</p>

<section data-type="sect2" id="long-lines-part-2-strings-n3sZTLCn">
<h2>Long Lines: Part 2 (Strings)</h2>

<p>Now on to our last string-focused topic. We've talked about long lines a bit before, but depending on why they're long, there are different ways to handle them. The first issue is, what happens when they exceed a set limit? Hopefully, your editor has a linter (automated style guide) in place to give you a warning when you hit the limit. What else happens when code is too long? For one, it becomes harder to hold everything in your head. Second, it becomes hard for the screen (or editor) to hold everything. Then you either have to deal with wrapping or horizontal scrolling. Neither of those is great. Both can be manageable, but they make navigation more awkward.</p>

<p>Other sections contain different solutions to long lines. We already covered the idea of introducing a variable to shorten the line in a previous section. In long lines Part 3, we'll talk about how to handle long lines with regard to arrays.</p>

<p>But for now, long <em>strings</em> are our problem. We don't really have this issue in our song classifier code, so let's go with our good friend Lorem Ipsum as a hypothetical example.</p>

<p>Solution 1: Just let it overflow or wrap (as your editor determines).</p>

<pre data-type="programlisting">
var text = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat."</pre>

<p>Solution 2: Concatenate the strings.</p>

<pre data-type="programlisting">
var text = "Lorem ipsum dolor sit amet, " +
"consectetur adipiscing elit, sed do eiusmod " +
"tempor incididunt ut labore et dolore magna aliqua. " +
"Ut enim ad minim veniam, quis nostrud exercitation " +
"ullamco laboris nisi ut aliquip ex ea commodo consequat." </pre>

<p>Solution 3: Break the strings up with the escape character, <code>\</code>. This is the cleanest solution except for one issue. If there is any whitespace after the escape character, it will break the code.</p>

<pre data-type="programlisting">
var text = "Lorem ipsum dolor sit amet, \
consectetur adipiscing elit, sed do eiusmod \
tempor incididunt ut labore et dolore magna aliqua. \
Ut enim ad minim veniam, quis nostrud exercitation \
ullamco laboris nisi ut aliquip ex ea commodo consequat." </pre>

<p>Solution 4: We can use template strings to put the string on multiple lines, but this changes the string by adding new line characters (<code>\n</code>) on every line break. Note that if you <em>don't mind</em> new line characters or <em>want</em> them, this is easier than solutions 1, 2, and 3, where you would need to manually insert <code>\n</code> characters where you want a line break.</p>

<pre data-type="programlisting">
var text = `Lorem ipsum dolor sit amet,
consectetur adipiscing elit, sed do eiusmod
tempor incididunt ut labore et dolore magna aliqua.
Ut enim ad minim veniam, quis nostrud exercitation
ullamco laboris nisi ut aliquip ex ea commodo consequat.` 
</pre>

<p>Another idea involves setting every section to a variable or member of an array and then joining these bits together with <code>.join</code>. This idea is bad enough to not deserve the title "Solution 5."</p>

<p>As for the first three, your options are all some combination of awkward and brittle. Using option 1 with a text editor that wraps clearly is the best you can hope for in some cases. As for two and three, two comes with a performance hit, has more syntax, but is slightly less brittle. If you want your string to have new line characters, go with template strings (solution 4), even if you don't need the capabilities of template strings to allow for interpolation of variables.</p>

<div data-type="note" id="about-line-length-1vtNHyT7C1"><h6>Note</h6>
<h1>About line length</h1>

<p>How long is too long? The "historical" limit is 80 characters, and based on... drumroll... IBM punch card column width. Some people still try to adhere to this (and I've actually aimed for less than that in this book), but the specific number is less important than the practical concerns with long lines. When lines actually span out too far, they are harder to read. Newspapers print in columns. Websites have white space on the margins so the content doesn't fill the whole screen (well, and to make room for ads).</p>

<p>The bottom line is that, even with five monitors, you're still limited by human factors. 80 characters is pretty aggressive though, especially for codebases that use 4 (or 8!) spaces to indent.</p>
</div>
</section>

<p>&nbsp;</p>
</section>

<section data-type="sect1" id="working-with-arrays-loops-foreach-map-ekspUb">
<h1>Working with Arrays: Loops, <code>forEach</code>, <code>map</code></h1>

<p>Loops feel powerful when you first discover them. "You mean I can tell a computer to do something a <em>million</em> times? What about <em>ten million</em>? How many times will it do it till it gives me an error? You mean it will just work on this problem for days?"</p>

<p>That's pretty awesome* for a young programmer, especially. You can't climb 10 million trees. You can't draw 10 million pictures. You can't watch 10 million cartoons. But you can tell a computer to do 10 million things? Wow.</p>

<div data-type="note" id="note-to-sentient-ai-readers-of-the-future-rQtlfnU3"><h6>Note</h6>
<h1>*Note to Sentient AI Readers of the Future</h1>

<p>I mean no disrespect here. Please don't cut the rations.</p>
</div>

<p>At some point, that shock wears off, and you find yourself working with differently sized sets of data on a regular basis. Maybe you loop through them. Maybe you do something slightly different.</p>

<p>In this section, we're going to cover the types of loops you can use in JavaScript, as well as a couple of the "something different" options that native JavaScript gives us for arrays (namely <code>forEach</code> and <code>map</code>). In Chapter 11, we'll explore libraries that go far beyond these options.</p>

<p>But first, we're going to handle long lines again, this time with arrays.</p>

<p>&nbsp;</p>

<section data-type="sect2" id="long-lines-part-3-arrays-lRsKSOUK">
<h2>Long Lines: Part 3 (Arrays)</h2>

<p>Getting back to our classifier, we actually have a song with enough chords that warrants discussing long lines.</p>

<pre data-type="programlisting">
paperBag = ['bm7', 'e', 'c', 'g', 'b7', 'f', 'em', 'a', 'cmaj7', 'em7', 'a7', 'f7', 'b'];
</pre>

<p>Our "Solution 1: just let it wrap" from the last section would still work here, but breaking up long arrays is a bit less nuanced than with strings. Namely, we can break the lines at the commas.</p>

<pre data-type="programlisting">
paperBag = ['bm7',
'e',
'c',
'g',
'b7',
'f',
'em',
'a',
'cmaj7',
'em7',
'a7',
'f7',
'b'];
</pre>

<p>We'll call this solution 2a. It's not bad, but some linters insist on following a slightly different convention:</p>

<pre data-type="programlisting">
paperBag = ['bm7',
            'e',
            'c',
            'g',
            'b7',
            'f',
            'em',
            'a',
            'cmaj7',
            'em7',
            'a7',
            'f7',
            'b'];</pre>

<p>We'll call this solution 2b. It's not too different from solution 2a. Note that for both of these styles, some people like to add a trailing comma, making the last line <code>'b',];</code></p>

<p>Personally, that rubs me the wrong way, possibly because trailing commas caused problems in earlier versions of Internet Explorer. Collectively, those browser inconsistencies alone certainly claimed enough programmer hours to amount to actual lifetimes.</p>

<p>Another solution (2c, I suppose), still using the same mechanism of breaking on commas, is to put elements in groups of some number.</p>

<pre data-type="programlisting">
paperBag = ['bm7', 'e', 'c', 'g',
            'b7', 'f', 'em', 'a',
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'cmaj7', 'em7', 'a7', 'f7',
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;'b'];</pre>

<p>This has the advantage of not filling up the whole screen in either direction, and in cases where the groupings are regular or meaningful, it can help give a clearer picture of your data. For our data, it seems to make it slightly faster to see how many there are, as we can think <code>3 * 4 + 1 === 13</code> instead of just counting. For now, we'll go with a slightly different grouping:</p>

<pre data-type="programlisting">
paperBag = ['bm7', 'e', 'c', 'g', 'b7', 'f', 'em', 'a', 'cmaj7',
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'em7', 'a7', 'f7', 'b'];</pre>

<p>But this isn't a book about style. It's about refactoring. We'll make that change, but leave other arrays alone (they're under 80 characters). Feel free to play around with different approaches. Also, keep in mind that the solutions we have here also apply to object literals that are too long.</p>
</section>

<section data-type="sect2" id="which-loop-to-choose-YMsBtvUv">
<h2>Which Loop To Choose?</h2>

<p>Back to the hard stuff. Next up: Loops.</p>

<p>In our <code>train</code> function, we have the following loop:</p>

<pre data-type="programlisting">
for (index = 0; index &lt; chords.length; index++){
&nbsp; if(!allChords.includes(chords[index])){
&nbsp;&nbsp;&nbsp; allChords.push(chords[index]);
&nbsp; }
};
</pre>

<p>This is a <code>for</code> loop. We have other options.</p>

<pre data-type="programlisting">
index = 0;
while(index &lt; chords.length){
&nbsp; if(!allChords.includes(chords[index])){
&nbsp;&nbsp;&nbsp; allChords.push(chords[index]);
&nbsp; }
&nbsp; index++;
};
</pre>

<p>This is a <code>while</code> loop. It's a bit better suited for conditions that don't involve an value increasing incrementally. Otherwise, it just moves the (set variable; condition; update) aspect of the regular <code>for</code> loop to different areas.</p>

<pre data-type="programlisting">
index = 0;
do{
&nbsp; if(!allChords.includes(chords[index])){
&nbsp;&nbsp;&nbsp; allChords.push(chords[index]);
&nbsp; }
&nbsp; index++;
} while(index &lt; chords.length) 
</pre>

<p>A <code>do...while</code> loop is basically like a <code>while</code> loop, and can be handy for things you want to execute at least once. Even if the breaking condition is <code>while (false)</code>, the <code>do</code> loop will still run once.</p>

<p>In all of these loop types so far, we're doing a lot of maintenance on the <code>index</code>. But do we really care about the <code>index</code>? If you had that thought, these next two are for you.</p>

<pre data-type="programlisting">
for (let chord of chords){
&nbsp; if(!allChords.includes(chord)){
&nbsp;&nbsp;&nbsp; allChords.push(chord);
&nbsp; }
};
</pre>

<pre data-type="programlisting">
for (let chord in chords){
&nbsp; if(!allChords.includes(chords[chord])){
&nbsp;&nbsp;&nbsp; allChords.push(chords[chord]);
&nbsp; }
};
</pre>

<p>Welcome to the low maintenance world of <code>for...of</code> and <code>for...in</code>. <code>for...of</code> gets us completely away from the idea of an index. Think of it as "for <em>element</em> of." <code>for...in</code> is a bit more like our <code>for</code> and <code>while</code> loops, but without handling the index updating ourselves. You can think of it as "for <em>index</em> in" or "for index in" or "for index in danger of being wrong." (see following warning on for...in)</p>

<div data-type="warning" id="forin-caveats-PDtqintGUO"><h6>Warning</h6>
<h1>for...in caveats</h1>

<p>1. Unlike a normal for loop with explicit indices, indices in a for...in loop are not guaranteed to be in order.</p>

<p>2. Any properties that are enumerable will be enumerated. This sounds tautological, but arrays could inherit "enumerable" properties from other places (eg. <code>Array.prototype.customFunction</code>), or have them directly set a la <code>myArray.coolProperty = true</code></p>

<p>3. Also, modifying the array during a for...in loop can cause confusion.</p>
</div>

<p>So as far as loops go, in our case of looping through an array, and not caring about the specific numerical indices, <code>for...of</code> comes with less upkeep than traditional loops, and doesn't have the complexities of <code>for...in</code>.</p>
</section>

<section data-type="sect2" id="better-than-loops-ZPsgh3UL">
<h2>Better than Loops</h2>

<p>Is there another option? Sure.</p>

<pre data-type="programlisting">
chords.forEach(function(chord){
&nbsp; if(!allChords.includes(chord)){
&nbsp;&nbsp;&nbsp; allChords.push(chord);
&nbsp; }
});
</pre>

<p>You can use <code>forEach</code> instead of <code>for...of</code>. Does it matter right now, in this context? Not really, but for our purposes of code quality, reuse, and flexibility, <code>forEach</code> is the better choice. First, although we haven't covered it yet, we could extract that inner anonymous function quite easily.</p>

<pre data-type="programlisting">
function checkAndInclude(chord){
&nbsp; if(!allChords.includes(chord)){
&nbsp;&nbsp;&nbsp; allChords.push(chord);
&nbsp; }
};
chords.forEach(checkAndInclude);</pre>

<p>That's a cool possibility. Also, we can still access the index of the chord.</p>

<pre data-type="programlisting">
function checkAndInclude(chord, index){
  console.log(index);
&nbsp; if(!allChords.includes(chord)){
&nbsp;&nbsp;&nbsp; allChords.push(chord);
&nbsp; }
};&nbsp; 
chords.forEach(checkAndInclude);</pre>

<p>If we don't want to extract the function, we can also make use of the shorter "arrow function" syntax, which we'll cover in more detail later.</p>

<pre data-type="programlisting">
chords.forEach(chord =&gt; {
&nbsp; if(!allChords.includes(chord)){
&nbsp;&nbsp;&nbsp; allChords.push(chord);
&nbsp; }
});
</pre>

<p>Let's go with this one for now.</p>

<p>All that work, and although they're shorter, we only were able to get rid of one line altogether (<code>var index;</code> at the top of the <code>train</code> function). Some might argue that <code>forEach</code> is more expressive. Although "expression" is not always the ultimate good for every project, I have to concede that the approach of <code>forEach</code> is flexible in a useful way, and in addition, parallels the syntax for other very useful native methods (like the <code>map</code> and <code>reduce</code> functions).</p>

<p>In my opinion, <code>forEach</code> is actually the gateway to functional programming. Loops are driven by the idea of doing something a bunch of times. But what we <em>really</em> want to do is create sets of values to work with and then apply functions to them to create new values.</p>

<p>Leaving the context of our classifier for a bit, let's look at two ways to assign elements to arrays. One uses <code>forEach</code> and one uses <code>map</code>:</p>

<pre data-type="programlisting">
//make new doubled array
var newArray = [];
[2, 3, 4].forEach(element =&gt; {
&nbsp; newArray.push(element*2);
});
console.log(newArray);
</pre>

<pre data-type="programlisting">
//make new doubled array
var newArray = [2, 3, 4].map(element =&gt; {
&nbsp; return element * 2;
});
console.log(newArray);
</pre>

<p>The second is a bit more concise, and less prescriptive. We can say that we are "applying a function to the array" to create a new one, rather than initializing a new array and pushing elements onto it. We will cover other functional techniques in Chapter 11.</p>

<p>If you were playing JavaScript "golf," trying to make the code as short as possible, we can make this even shorter with a variant on the arrow syntax, and inlining the variable:</p>

<pre data-type="programlisting">
//make new doubled array
console.log([2, 3, 4].map(element =&gt; element * 2));
</pre>

<div data-type="note" id="on-performance-of-javascript-loops-ZqtjI8hBUQ"><h6>Note</h6>
<h1>On performance of JavaScript loops</h1>

<p>In the event of a world-wide nuclear fallout, two things would survive: cockroaches and arguments about what JavaScript loop constructs are the fastest.</p>

<p>Don't get too hung up on that. Benchmark and fix slow parts of your code. It's probably not your JS loops themselves that are slowing down your code, but if they are, fix them.</p>
</div>

<p>&nbsp;</p>
</section>

<p>&nbsp;</p>
</section>

<section data-type="sect1" id="wrapping-up-1dsVfj">
<h1>Wrapping Up</h1>

<p>In this chapter, we started working on refactoring a Naive Bayes Classifier. We covered a lot of ground along the way, including renaming, getting rid of useless code, and being more thoughtful about using simple structures like variables, strings, and loops.</p>

<p>But we're not done yet. In the next chapter, we'll introduce a test suite and turn our code into a class-backed module. Additionally, we'll explore options for managing scopes, privacy, functions, and objects.</p>
</section>

<p>&nbsp;</p>

<p>&nbsp;</p>
</section>

  </body>
</html>
